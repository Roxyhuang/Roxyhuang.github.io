<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    
    <title>你不知道的js复习笔记 (对象) | Neo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="一. 语法对象可以通过两种形式定义:字面量和构造形式 1. 字面量常用 123var myObj = &amp;#123; 	key: value,	// ... &amp;#125;; 2. 构造形式不常用 12var myObj = new Object();myObj.key = value; 区别是，在文字声明中你可以添加多个 键 / 值对，但是在构造形式中你必须逐个添加属性。 2. 类型对象是 Jav">
<meta property="og:type" content="article">
<meta property="og:title" content="你不知道的js复习笔记 (对象)">
<meta property="og:url" content="http://www.neohuang.com/child/2018/09/29/not-know-js-review-object/index.html">
<meta property="og:site_name" content="Neo">
<meta property="og:description" content="一. 语法对象可以通过两种形式定义:字面量和构造形式 1. 字面量常用 123var myObj = &amp;#123; 	key: value,	// ... &amp;#125;; 2. 构造形式不常用 12var myObj = new Object();myObj.key = value; 区别是，在文字声明中你可以添加多个 键 / 值对，但是在构造形式中你必须逐个添加属性。 2. 类型对象是 Jav">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://www.neohuang.com/img/not-know-js-review.jpeg">
<meta property="og:updated_time" content="2018-09-29T07:01:52.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="你不知道的js复习笔记 (对象)">
<meta name="twitter:description" content="一. 语法对象可以通过两种形式定义:字面量和构造形式 1. 字面量常用 123var myObj = &amp;#123; 	key: value,	// ... &amp;#125;; 2. 构造形式不常用 12var myObj = new Object();myObj.key = value; 区别是，在文字声明中你可以添加多个 键 / 值对，但是在构造形式中你必须逐个添加属性。 2. 类型对象是 Jav">
<meta name="twitter:image" content="http://www.neohuang.com/img/not-know-js-review.jpeg">
    

    

    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
    
    


</head>

<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <!--<span class="site-title">Neo</span>-->
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/.">Home</a>
                
                    <a class="main-nav-link" href="/archives">Archives</a>
                
            </nav>
            
                
                <nav id="sub-nav">
                    <div class="profile" id="profile-nav">
                        <a id="profile-anchor" href="javascript:;">
                            <img class="avatar" src="/css/images/doge.jpeg" />
                            <i class="fa fa-caret-down"></i>
                        </a>
                    </div>
                </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/.">Home</a></td>
                
                    <td><a class="main-nav-link" href="/archives">Archives</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search" />
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
                

<aside id="profile">
    <div class="inner profile-inner">
        <div class="base-info profile-block">
            <img id="avatar" src="/css/images/doge.jpeg" />
            <h2 id="name">Neo Huang</h2>
            <h3 id="title">Front End Developer</h3>
            <span id="location"><i class="fa fa-map-marker"></i>Shanghai, China</span>
            <a id="follow" target="_blank" href="https://github.com/Roxyhuang">FOLLOW</a>
        </div>
        <div class="article-info profile-block">
            <div class="article-info-block">
                26
                <span>posts</span>
            </div>
            <div class="article-info-block">
                0
                <span>tag</span>
            </div>
        </div>
        
        <div class="profile-block social-links">
            <table>
                <tr>
                    
                    
                    <td>
                        <a href="https://github.com/Roxyhuang" target="_blank" title="github" class=tooltip>
                            <i class="fa fa-github"></i>
                        </a>
                    </td>
                    
                </tr>
            </table>
        </div>
        
    </div>
</aside>

            
            <section id="main"><article id="post-not-know-js-review-object" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
            你不知道的js复习笔记 (对象)
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2018/09/29/not-know-js-review-object/">
            <time datetime="2018-09-28T16:00:00.000Z" itemprop="datePublished">2018-09-29</time>
        </a>
    </div>


                        
                        
                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h2 id="一-语法"><a href="#一-语法" class="headerlink" title="一. 语法"></a>一. 语法</h2><p>对象可以通过两种形式定义:字面量和构造形式</p>
<h3 id="1-字面量"><a href="#1-字面量" class="headerlink" title="1. 字面量"></a>1. 字面量</h3><p>常用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123; </span><br><span class="line">	key: value,	<span class="comment">// ... </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-构造形式"><a href="#2-构造形式" class="headerlink" title="2. 构造形式"></a>2. 构造形式</h3><p>不常用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">myObj.key = value;</span><br></pre></td></tr></table></figure>
<p><strong>区别</strong>是，在文字声明中你可以添加多个 键 / 值对，但是在构造形式中你必须逐个添加属性。</p>
<h3 id="2-类型"><a href="#2-类型" class="headerlink" title="2. 类型"></a>2. 类型</h3><p>对象是 JavaScript 的基础。在 JavaScript 中一共有六种主要类型(术语是“语言类型”):</p>
<ul>
<li>string </li>
<li>number </li>
<li>boolean </li>
<li>null</li>
<li>undefined </li>
<li>object</li>
</ul>
<h4 id="1-简单数据类型的一些注意"><a href="#1-简单数据类型的一些注意" class="headerlink" title="(1)简单数据类型的一些注意"></a>(1)简单数据类型的一些注意</h4><p><strong>注意</strong>，简单基本类型(string、boolean、number、null 和 undefined)本身并不是对象。 null 有时会被当作一种对象类型，但是这其实只是语言本身的一个 bug，即对 null 执行 typeof null时会返回字符串”object”。1实际上，null本身是基本类型。</p>
<p>JavaScript 中万物皆是对象”，这显然是<strong>错误</strong>的。</p>
<h4 id="2-复杂数据类型的一些注意"><a href="#2-复杂数据类型的一些注意" class="headerlink" title="(2)复杂数据类型的一些注意"></a>(2)复杂数据类型的一些注意</h4><p>JavaScript 中有许多特殊的对象子类型，我们可以称之为复杂基本类型。</p>
<ul>
<li><p>函数就是对象的一个子类型(从技术角度来说就是“可调用的对象”)。</p>
<p>  JavaScript 中的函数是“一等公民”，因为它们本质上和普通的对象一样(只是可以调用)，所以可以像操作 其他对象一样操作函数(比如当作另一个函数的参数)。</p>
</li>
<li><p>数组也是对象的一种类型，具备一些额外的行为。数组中内容的组织方式比一般的对象要 稍微复杂一些。</p>
</li>
</ul>
<h4 id="3-内置对象"><a href="#3-内置对象" class="headerlink" title="(3)内置对象"></a>(3)内置对象</h4><p>JavaScript 中还有一些对象子类型，通常被称为内置对象。有些内置对象的名字看起来和 简单基础类型一样</p>
<ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Object</li>
<li>Function</li>
<li>Array</li>
<li>Date</li>
<li>RegExp</li>
<li>Error</li>
</ul>
<p>这些内置对象从表现形式来说很像其他语言中的类型(type)或者类(class)，比如 Java 中的 String 类。</p>
<p>但是在 JavaScript 中，它们实际上只是一些内置函数。这些内置函数可以当作构造函数 (由 new 产生的函数调用——参见第 2 章)来使用，从而可以构造一个对应子类型的新对象。举例来说:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strPrimitive = <span class="string">"I am a string"</span>; <span class="keyword">typeof</span> strPrimitive; <span class="comment">// "string" strPrimitive instanceof String; // false</span><span class="keyword">var</span> strObject = <span class="keyword">new</span> <span class="built_in">String</span>( <span class="string">"I am a string"</span> ); </span><br><span class="line"><span class="keyword">typeof</span> strObject; <span class="comment">// "object"</span>strObject <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">// true</span><span class="comment">// 检查 sub-type 对象</span><span class="built_in">Object</span>.prototype.toString.call( strObject ); <span class="comment">// [object String]</span></span><br></pre></td></tr></table></figure>
<p>暂时不关心Object.prototype.toString的工作原理，我们可以认为子类型在内部借用了 Object 中的 toString() 方法。</p>
<p><strong>特别注意</strong></p>
<p>原始值 “I am a string” 并不是一个对象，它只是一个字面量，并且是一个不可变的值。如果要在这个字面量上执行一些操作，比如获取长度、访问其中某个字符等，那需要将其 转换为 String 对象。幸好，在必要时语言会自动把字符串字面量转换成一个 String 对象，也就是说你并不需要 显式创建一个对象。JavaScript 社区中的大多数人都认为能使用文字形式时就不要使用构 造形式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strPrimitive = <span class="string">"I am a string"</span>; </span><br><span class="line"><span class="comment">// 可以理解为 String(strPrimitive).length;</span></span><br><span class="line"><span class="built_in">console</span>.log( strPrimitive.length ); <span class="comment">// 13</span></span><br><span class="line"><span class="comment">// 可以理解为 String(strPrimitive).charAt( 3 );</span></span><br><span class="line"><span class="built_in">console</span>.log( strPrimitive.charAt( <span class="number">3</span> ) ); <span class="comment">// "m"</span></span><br></pre></td></tr></table></figure>
<p>使用以上两种方法，我们都可以直接在字符串字面量上访问属性或者方法，之所以可以这 样做，是因为引擎自动把字面量转换成 String 对象，所以可以访问属性和方法。</p>
<ul>
<li><strong>string、number以及boolean都同上。但null 和 undefined 没有对应的构造形式，它们只有文字形式。相反，Date 只有构造，没有文字形式。</strong></li>
<li>object、Array、Function 和 RegExp(正则表达式),无论使用文字形式还是构造形式,它们都是<strong>对象</strong>，不是<strong>字面量</strong>。在某些情况下，相比用文字形式创建对象，构造形 式可以提供一些额外选项。</li>
<li>Error 对象很少在代码中显式创建，一般是在抛出异常时被自动创建。也可以使用 new Error(..) 这种构造形式来创建，不过一般来说用不着。</li>
</ul>
<h3 id="3-内容"><a href="#3-内容" class="headerlink" title="3. 内容"></a>3. 内容</h3><p>对象的内容是由一些存储在特定命名位置的(任意类型的)值组成的，我们称之为属性。</p>
<p><strong>强调：</strong></p>
<p>在引擎内部，这些值的存储方式是多种多样的，一般并不会存 在对象容器内部。存储在对象容器内部的是这些属性的名称，它们就像指针(从技术角度 来说就是引用)一样，指向这些值真正的存储位置。</p>
<h4 id="1-属性访问"><a href="#1-属性访问" class="headerlink" title="(1)属性访问"></a>(1)属性访问</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; </span><br><span class="line">	a: <span class="number">2</span>&#125;;myObject.a; <span class="comment">// 2</span>myObject[<span class="string">"a"</span>]; <span class="comment">// 2</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">我们需要使用 . 操作符或者 [] 操作符来访问对象的属性，.a 语法通 常被称为“属性访问”，["a"] 语法通常被称为“键访问”。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">##### [1]两者的区别：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- . 操作符要求属性名满足标识符的命名规范</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">- 而 [".."] 语法 可以接受任意 UTF-8/Unicode 字符串作为属性名。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	`</span><span class="string">``</span>javascript</span><br><span class="line">	myObject[<span class="string">'Super- Fun!'</span>] <span class="comment">// 合法</span></span><br><span class="line">	myObject.Super-FUN! <span class="comment">// 不合法</span></span><br></pre></td></tr></table></figure>
<ul>
<li>由于 [“..”] 语法使用字符串来访问属性，所以可以在程序中构造这个字符串</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; </span><br><span class="line">	a:<span class="number">2</span>&#125;;<span class="keyword">var</span> idx;<span class="keyword">if</span> (wantA) &#123; </span><br><span class="line">	idx = <span class="string">"a"</span>;&#125;<span class="comment">// 之后</span><span class="built_in">console</span>.log( myObject[idx] ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>在对象中，属性名永远都是字符串。</strong>,如果你使用 string(字面量)以外的其他值作为属性 名，那它首先会被转换为一个字符串。即使是数字也不例外，虽然在数组下标中使用的的 确是数字，但是在对象属性名中数字会被转换成字符串，所以当心不要搞混对象和数组中 数字的用法:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;;myObject[<span class="literal">true</span>] = <span class="string">"foo"</span>; </span><br><span class="line">myObject[<span class="number">3</span>] = <span class="string">"bar"</span>; </span><br><span class="line">myObject[myObject] = <span class="string">"baz"</span>;myObject[<span class="string">"true"</span>]; <span class="comment">// "foo"</span>myObject[<span class="string">"3"</span>]; <span class="comment">// "bar"</span>myObject[<span class="string">"[object Object]"</span>]; <span class="comment">// "baz"</span></span><br></pre></td></tr></table></figure>
<h4 id="2-可计算属性名"><a href="#2-可计算属性名" class="headerlink" title="(2)可计算属性名"></a>(2)可计算属性名</h4><h5 id="1-可计算属性名"><a href="#1-可计算属性名" class="headerlink" title="[1] 可计算属性名"></a>[1] 可计算属性名</h5><p>实际是通过这种形式 myObject[prefix + name]，但是使用文字形式来声明对 象时这样做是不行的。</p>
<p>ES6 增加了可计算属性名，可以在文字形式中使用 [] 包裹一个表达式来当作属性名:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> prefix = <span class="string">"foo"</span>;<span class="keyword">var</span> myObject = &#123;	[prefix + <span class="string">"bar"</span>]:<span class="string">"hello"</span>, </span><br><span class="line">	[prefix + <span class="string">"baz"</span>]: <span class="string">"world"</span>&#125;;myObject[<span class="string">"foobar"</span>]; <span class="comment">// hello</span>myObject[<span class="string">"foobaz"</span>]; <span class="comment">// world</span></span><br></pre></td></tr></table></figure>
<h5 id="2-Symbol"><a href="#2-Symbol" class="headerlink" title="[2] Symbol"></a>[2] Symbol</h5><p>可计算属性名最常用的场景可能是 ES6 的符号(Symbol)，简单来说，它们是一种新的基础数据类型，包含一个不透明且无法预测的值(从技术角度来说就是一个字符串)。</p>
<p>一般来说你不会用到符号的实际值(因为理论上来说在不 同的 JavaScript 引擎中值是不同的)，所以通常你接触到的是符号的名称，比如 Symbol. Something(这个名字是我编的):</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;	[<span class="built_in">Symbol</span>.Something]: <span class="string">"hello world"</span>&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-属性与方法"><a href="#3-属性与方法" class="headerlink" title="[3] 属性与方法"></a>[3] 属性与方法</h5><p><strong>请不要在js中不要混淆函数和方法的概念</strong></p>
<p>如果访问的对象属性是一个函数,有些开发者喜欢使用不一样的叫法以作区分,由于函数 很容易被认为是属于某个对象，在其他语言中，属于对象(也被称为“类”)的函数通常 被称为“方法”，因此把“属性访问”说成是“方法访问”也就不奇怪了。</p>
<p>js中虽然也有类似规范，但不是从技术上来说不是特别准确。</p>
<p>有些函数具有 this 引用，有时候这些 this 确实会指向调用位置的对象引用。但是 这种用法从本质上来说并没有把一个函数变成一个“方法”，因为 this 是在运行时根据调 用位置动态绑定的，所以函数和对象的关系最多也只能说是间接关系。</p>
<p>无论返回值是什么类型，每次访问对象的属性就是属性访问。如果属性访问返回的是一个 函数，那它也并不是一个“方法”。属性访问返回的函数和其他函数没有任何区别(除了 可能发生的隐式绑定 this，就像我们刚才提到的)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">"foo"</span> );&#125;<span class="keyword">var</span> someFoo = foo; <span class="comment">//对foo的变量引用</span><span class="keyword">var</span> myObject = &#123; </span><br><span class="line">	someFoo: foo&#125;;foo; <span class="comment">// function foo()&#123;..&#125;</span>someFoo; <span class="comment">// function foo()&#123;..&#125; </span></span><br><span class="line">myObject.someFoo; <span class="comment">// function foo()&#123;..&#125;</span></span><br></pre></td></tr></table></figure>
<p>例子中foo全是指向同一个foo函数</p>
<p>someFoo 和 myObject.someFoo 只是对于同一个函数的不同引用，并不能说明这个函数是特别的或者“属于”某个对象。如果 foo() 定义时在内部有一个 this 引用，那这两个函数引用的<strong>唯一区别</strong>就是 myObject.someFoo 中的 this 会被隐式绑定到一个对象。<strong>无论哪种引用 形式都不能称之为“方法”</strong>。</p>
<p>或许有人会辩解说，函数并不是在定义时成为方法，而是在被调用时根据调用位置的不同 (是否具有上下文对象——详见第 2 章)成为方法。即便如此，这种说法仍然有些不妥。</p>
<p>因此最保险的说法可能是，“函数”和“方法”在 JavaScript 中是可以互换的。</p>
<p>ES6 增加了 super 引用，一般来说会被用在 class 中(参见附录 A)。super 的行为似乎更有理由把 super 绑定的函数称为“方法”。但是再说一次，这 些只是一些语义(和技术)上的微妙差别，本质是一样的。</p>
<p>即使你在对象的文字形式中声明一个函数表达式，这个函数也不会“属于”这个对象—— 它们只是对于相同函数对象的多个引用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;	<span class="attr">foo</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;       	<span class="built_in">console</span>.log( <span class="string">"foo"</span> );     	&#125;&#125;;<span class="keyword">var</span> someFoo = myObject.foo; </span><br><span class="line">someFoo; <span class="comment">// function foo()&#123;..&#125; </span></span><br><span class="line">myObject.foo; <span class="comment">// function foo()&#123;..&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>ps:</strong>ES6 增加的一种 简易函数声明语法，属性声明语法。</p>
<h4 id="3-数组"><a href="#3-数组" class="headerlink" title="(3) 数组"></a>(3) 数组</h4><p>数组也支持 [] 访问形式，不过数组有一套更加结构化的值存储 机制(不过仍然不限制值的类型)</p>
<p>数组期望的是数值下标，也就是说值存储的位置。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArray = [ <span class="string">"foo"</span>, <span class="number">42</span>, <span class="string">"bar"</span> ]; </span><br><span class="line">myArray.length; <span class="comment">// 3</span>myArray[<span class="number">0</span>]; <span class="comment">// "foo"</span>myArray[<span class="number">2</span>]; <span class="comment">// "bar"</span></span><br></pre></td></tr></table></figure>
<p>数组也是对象，所以虽然每个下标都是整数，你仍然可以给数组添加属性:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var myArray = [ &quot;foo&quot;, 42, &quot;bar&quot; ];</span><br><span class="line">myArray.baz = &quot;baz&quot;;  // 会增加一个baz: &quot;baz&quot;</span><br><span class="line">myArray.length; // 3myArray.baz; // &quot;baz&quot;</span><br></pre></td></tr></table></figure>
<p><strong>需要注意：</strong>虽然添加了命名属性(无论是通过 . 语法还是 [] 语法)，数组的 length 值并未发 生变化。</p>
<p>你完全可以把数组当作一个普通的键 / 值对象来使用，并且不添加任何数值索引，但是这 并不是一个好主意。数组和普通的对象都根据其对应的行为和用途进行了优化（不建议）</p>
<p><strong>需要注意：</strong>:如果你试图向数组添加一个属性，但是属性名“看起来”像一个数字，那它会变成 一个数值下标(因此会修改数组的内容而不是添加一个属性):</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArray = [ <span class="string">"foo"</span>, <span class="number">42</span>, <span class="string">"bar"</span> ]; </span><br><span class="line">myArray[<span class="string">"3"</span>] = <span class="string">"baz"</span>;  <span class="comment">// 转化为了int 3</span></span><br><span class="line">myArray.length; <span class="comment">// 4</span>myArray[<span class="number">3</span>]; <span class="comment">// "baz"</span></span><br></pre></td></tr></table></figure>
<h4 id="4-复制对象"><a href="#4-复制对象" class="headerlink" title="(4) 复制对象"></a>(4) 复制对象</h4><p>这个问题上我们应需要考虑深拷贝和浅拷贝</p>
<p>从一个例子来分析</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">anotherFunction</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*..*/</span> &#125;<span class="keyword">var</span> anotherObject = &#123; </span><br><span class="line">	c: <span class="literal">true</span>&#125;;<span class="keyword">var</span> anotherArray = [];<span class="keyword">var</span> myObject = &#123; </span><br><span class="line">	a: <span class="number">2</span>,	<span class="attr">b</span>: anotherObject, <span class="comment">// 引用，不是复本! </span></span><br><span class="line">	c: anotherArray, <span class="comment">// 另一个引用!</span>	d: anotherFunction&#125;;</span><br><span class="line"></span><br><span class="line">anotherArray.push( anotherObject, myObject ); <span class="comment">// 很关键</span></span><br></pre></td></tr></table></figure>
<h5 id="1-浅拷贝"><a href="#1-浅拷贝" class="headerlink" title="[1] 浅拷贝"></a>[1] 浅拷贝</h5><p><strong>复制出的新对象时，基础数据类型会copy值，引用数据类型仅拷贝引用。</strong></p>
<p>复制出的新对象中 a 的值会 复制旧对象中 a 的值，也就是 2，但是新对象中 b、c、d 三个属性其实只是三个引用，它们 和旧对象中 b、c、d 引用的对象是一样的。</p>
<p>相比深复制，浅复制非常易懂并且问题要少得多，所以 ES6 定义了 Object.assign(..) 方 法来实现浅复制。</p>
<p>Object.assign(..) 方法的第一个参数是目标对象，之后还可以跟一个 或多个源对象。它会遍历一个或多个源对象的所有可枚举(enumerable，参见下面的代码) 的自有键(owned key，很快会介绍)并把它们复制(使用 = 操作符赋值)到目标对象，最 后返回目标对象，就像这样:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... myobject代码</span></span><br><span class="line"><span class="keyword">var</span> newObj = <span class="built_in">Object</span>.assign( &#123;&#125;, myObject );newObj.a; <span class="comment">// 2</span>newObj.b === anotherObject; <span class="comment">// true</span>newObj.c === anotherArray; <span class="comment">// true</span>newObj.d === anotherFunction; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>需要注意的一点是，由于 Object.assign(..) <strong>相当于使用 = 操作符来赋值</strong>，所 以源对象属性的<strong>一些特性(比如 writable)不会被复制到目标对象</strong>。</p>
<h5 id="2-深拷贝"><a href="#2-深拷贝" class="headerlink" title="[2] 深拷贝"></a>[2] 深拷贝</h5><p><strong>复制出的新对象时，基础数据类型复制新对象</strong></p>
<p>首先上面的例子不能用深拷贝，关键就是最后一句代码，因为了复制 myObject 以外还会复 制 anotherObject 和 anotherArray，这时问题就来了，anotherArray 引用了 anotherObject 和 myObject，所以又需要复制 myObject，这样就会由于循环引用导致死循环。</p>
<h5 id="3-为什么不能封装成一个统一方法"><a href="#3-为什么不能封装成一个统一方法" class="headerlink" title="[3] 为什么不能封装成一个统一方法"></a>[3] 为什么不能封装成一个统一方法</h5><p>其实根本问题就是在于深拷贝的一些不确定性</p>
<ul>
<li><p>出现循环引用导致死循环</p>
<p>  我们是应该检测循环引用并终止循环(不复制深层元素)?还是应当直接报错或者是选择 其他方法?</p>
</li>
<li><p>我们还不确定“复制”一个函数意味着什么</p>
<p>  有些人会通过 toString() 来序列 化一个函数的源代码(但是结果取决于 JavaScript 的具体实现，而且不同的引擎对于不同 类型的函数处理方式并不完全相同)。</p>
</li>
<li><p>是否能保证对象是 JSON 安全的，所以只适用于部分情况。</p>
<p>  对于 JSON 安全(也就是说可以被序列化为一个 JSON 字符串并且可以根据这个字符串解 析出一个结构和值完全一样的对象)的对象来说，有一种巧妙的复制方法:</p>
<p>  <code>`</code>javascript<br>  var newObj = JSON.parse( JSON.stringify( someObj ) );</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### (6) 属性描述符</span><br><span class="line"></span><br><span class="line">在 ES5 之前，JavaScript 语言本身并没有提供可以直接检测属性特性的方法，比如判断属性是否是只读。</span><br><span class="line">但是从 ES5 开始，所有的属性都具备了属性描述符。</span><br><span class="line"></span><br><span class="line">##### [1] 创建并使用</span><br><span class="line"></span><br><span class="line">在创建普通属性时属性描述符会使用默认值，我们也可以使用 Object.defineProperty(..) 来添加一个新属性或者修改一个已有属性(如果它是 configurable)并对特性进行设置。</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">var obj = &#123;</span><br><span class="line">    a: 2,</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">Object.getOwnPropertyDescriptor(obj,&apos;a&apos;);</span><br><span class="line">// &#123;// value: 2,// writable: true,// enumerable: true,// configurable: true // &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如你所见，这个普通的对象属性对应的属性描述符(也被称为“数据描述符”，因为它 只保存一个数据值)可不仅仅只是一个 2。</p>
<p>它还包含另外三个特性:</p>
<ul>
<li>writable(可写) </li>
<li>enumerable(可枚举)</li>
<li>configurable(可配置)。</li>
</ul>
<p>在创建普通属性时属性描述符会使用默认值，我们也可以使用 Object.defineProperty(..) 来添加一个新属性或者修改一个已有属性(如果它是 configurable)并对特性进行设置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"a"</span>, &#123;</span><br><span class="line">  value: <span class="number">2</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myObject.a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(myObject, <span class="string">'a'</span>))</span><br></pre></td></tr></table></figure>
<h5 id="2-Writable"><a href="#2-Writable" class="headerlink" title="[2] Writable"></a>[2] Writable</h5><p><strong>特征：</strong></p>
<p>当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false。(与delete无关)</p>
<p><strong>原理：</strong></p>
<p>你可以把 writable:false 看 作是属性不可改变，相当于你定义了一个空操作 setter。严格来说，如果要 和 writable:false 一致的话，你的 setter 被调用时应当抛出一个 TypeError 错误。</p>
<p><strong>例子：</strong></p>
<p>非严格模式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;;   <span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"a"</span>, &#123;      <span class="attr">value</span>: <span class="number">2</span>,		<span class="attr">writable</span>: <span class="literal">false</span>, <span class="comment">// 不可写! configurable: true, enumerable: true</span>   &#125; );myObject.a = <span class="number">3</span>;myObject.a; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>严格模式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"a"</span>, &#123;</span><br><span class="line">   value: <span class="number">2</span>,</span><br><span class="line">   writable: <span class="literal">false</span>, <span class="comment">// 不可写! configurable: true, enumerable: true</span></span><br><span class="line">&#125; );</span><br><span class="line">myObject.a = <span class="number">3</span>; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>
<p>TypeError 错误表示我们无法修改一个不可写的属性。</p>
<h5 id="3-Configurable"><a href="#3-Configurable" class="headerlink" title="[3] Configurable"></a>[3] Configurable</h5><p><strong>特征：</strong></p>
<ul>
<li>当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变<strong>(可以理解成能够使用 defineProperty(..) </strong></li>
<li><p>同时该属性也能从对应的对象上被删除。默认为 false。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">   a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line">myObject.a = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myObject.a);<span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"a"</span>, &#123;</span><br><span class="line">  value: <span class="number">4</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">false</span>, <span class="comment">// 不可配置!</span></span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myObject.a);<span class="comment">// 4</span></span><br><span class="line">myObject.a = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myObject.a); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"a"</span>, &#123;</span><br><span class="line">  value: <span class="number">6</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125; ); <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>
<p>  最后一个 defineProperty(..) 会产生一个 TypeError 错误，不管是不是处于严格模式，尝 试修改一个不可配置的属性描述符都会出错。注意:如你所见，把 configurable 修改成 false 是单向操作，无法撤销!</p>
</li>
<li><p>要注意有一个小小的例外:即便属性是 configurable:false，我们还是可以 把 writable 的状态由 true 改为 false，但是无法由 false 改为 true。</p>
</li>
<li><p>configurable:false 还会禁止删除这个属性</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">var</span> myObject = &#123; </span><br><span class="line">		a:<span class="number">2</span>&#125;;myObject.a; <span class="comment">// 2</span><span class="keyword">delete</span> myObject.a; </span><br><span class="line">	myObject.a; <span class="comment">// undefined</span><span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"a"</span>, &#123;  	<span class="attr">value</span>: <span class="number">2</span>,	<span class="attr">writable</span>: <span class="literal">true</span>, </span><br><span class="line">		configurable: <span class="literal">false</span>, </span><br><span class="line">		enumerable: <span class="literal">true</span>&#125; );myObject.a; <span class="comment">// 2 </span></span><br><span class="line">	<span class="keyword">delete</span> myObject.a; </span><br><span class="line">	myObject.a; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>最后一个 delete 语句(静默)失败了，因为属性是不可配置的。
</code></pre><ul>
<li>不要把 delete 看作一个释放内存的工具(就像 C/C++ 中那 样)，它就是一个删除对象属性的操作。        </li>
</ul>
<h5 id="4-Enumerable"><a href="#4-Enumerable" class="headerlink" title="[4] Enumerable"></a>[4] Enumerable</h5><p><strong>特征：</strong></p>
<p>这个描述符控制的是属性是否会出现在对象的属性枚举中</p>
<p>for..in 循环。如果把 enumerable 设置成 false，这个属性就不会出现在枚举中，虽然仍 然可以正常访问它。相对地，设置成 true 就会让它出现在枚举中。</p>
<p>用户定义的所有的普通属性默认都是 enumerable，这通常就是你想要的。但是如果你不希 望某些特殊属性出现在枚举中，那就把它设置成 enumerable:false。</p>
<p>// todos</p>
<h4 id="7-不变性"><a href="#7-不变性" class="headerlink" title="(7) 不变性"></a>(7) 不变性</h4><p>所有的方法创建的都是浅不变形，也就是说，它们只会影响目标对象和 它的直接属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myImmutableObject 设置不可变</span></span><br><span class="line">myImmutableObject.foo; <span class="comment">// [1,2,3]</span>myImmutableObject.foo.push( <span class="number">4</span> );myImmutableObject.foo; <span class="comment">// [1,2,3,4] // foo属性仍可变</span></span><br></pre></td></tr></table></figure>
<p>myImmutableObject 已经被创建而且是不可变的，但是为了保护它的内容 myImmutableObject.foo，你还需要使用下面的方法让 foo 也不可变。</p>
<h5 id="1-对象常量"><a href="#1-对象常量" class="headerlink" title="[1]对象常量"></a>[1]对象常量</h5><p>结合 writable:false 和 configurable:false 就可以创建一个真正的常量属性(不可修改、 重定义或者删除):</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;;<span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"FAVORITE_NUMBER"</span>, &#123;   <span class="attr">value</span>: <span class="number">42</span>,	<span class="attr">writable</span>: <span class="literal">false</span>,	<span class="attr">configurable</span>: <span class="literal">false</span> </span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<h5 id="2-禁止扩展"><a href="#2-禁止扩展" class="headerlink" title="[2]禁止扩展"></a>[2]禁止扩展</h5><p>如果你想禁止一个<strong>对象添加新属性并且保留已有属性</strong>，可以使用 Object.prevent Extensions(..):</p>
<ul>
<li>仅不能添加属性</li>
<li>可用等号赋值属性</li>
<li>可用delete删除属性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; <span class="attr">a</span>:<span class="number">2</span> &#125;;<span class="built_in">Object</span>.preventExtensions( myObject );myObject.b = <span class="number">3</span>;myObject.b; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>在非严格模式下，创建属性 b 会静默失败。在严格模式下，将会抛出 TypeError 错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; <span class="attr">a</span>:<span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions( myObject );</span><br><span class="line">myObject.b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">delete</span> myObject.a;</span><br><span class="line"><span class="built_in">console</span>.log(myObject);</span><br></pre></td></tr></table></figure>
<p><strong>delete仍有效</strong></p>
<h5 id="3-密封"><a href="#3-密封" class="headerlink" title="[3] 密封"></a>[3] 密封</h5><p>Object.seal(..) 会创建一个“密封”的<strong>对象</strong>，这个方法实际上会在一个现有对象上调用 Object.preventExtensions(..) 并把所有现有属性标记为 configurable:false。<br>所以，密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性(虽然可以 修改属性的值)。</p>
<p>Object.seal(..):</p>
<ul>
<li>所有属性configurable:false</li>
<li>可用等号赋值属性</li>
<li>密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    prop: <span class="number">42</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.seal(obj);</span><br><span class="line"></span><br><span class="line">obj.prop = <span class="number">36</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.prop);<span class="comment">// 36</span></span><br><span class="line"></span><br><span class="line">obj.prop2 = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// obj: &#123;props: 22 &#125; 未添加成功</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.prop;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// obj: &#123;props: 22 &#125; 未删除成功</span></span><br></pre></td></tr></table></figure>
<h5 id="4-冻结"><a href="#4-冻结" class="headerlink" title="[4] 冻结"></a>[4] 冻结</h5><p>Object.freeze(..) 会创建一个冻结对象，这个方法实际上会在一个现有对象上调用 Object.seal(..) 并把所有“数据访问”属性标记为 writable:false，这样就无法修改它们 的值。</p>
<ul>
<li>创建一个冻结对象</li>
<li>不可复制属性，也不可添加，删除属性</li>
<li>最高的不可变性</li>
<li>对象引用的其他对象是不受影响的</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> obj = &#123;</span><br><span class="line">    prop: <span class="number">42</span>,</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.freeze(obj);</span><br><span class="line"></span><br><span class="line">obj.prop = <span class="number">36</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.prop);<span class="comment">// 42</span></span><br><span class="line"></span><br><span class="line">obj.prop2 = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// obj: &#123;props: 42 &#125; 未添加成功</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.prop;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// obj: &#123;props: 42 &#125; 未删除成功</span></span><br></pre></td></tr></table></figure>
<h5 id="5-深度冻结"><a href="#5-深度冻结" class="headerlink" title="[5] 深度冻结"></a>[5] 深度冻结</h5><p>你可以“深度冻结”一个对象，具体方法为，首先在这个对象上调用 Object.freeze(..)， 然后遍历它引用的所有对象并在这些对象上调用 Object.freeze(..)。但是一定要小心，因 为这样做有可能会在无意中冻结其他(共享)对象。</p>
<h4 id="8-GET"><a href="#8-GET" class="headerlink" title="(8) [[GET]]"></a>(8) [[GET]]</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; </span><br><span class="line">	a: <span class="number">2</span>&#125;;myObject.a; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h5 id="1-GET操作"><a href="#1-GET操作" class="headerlink" title="[1] GET操作"></a>[1] GET操作</h5><p>myObject.a 是一次属性访问，但是这条语句并不仅仅是在 myObjet 中查找名字为 a 的属性， 虽然看起来好像是这样。</p>
<p>myObject.a 在 myObject 上实际上是实现了 [[Get]] 操作(有点像函数调 用[[Get]]()</p>
<ol>
<li>对象默认的内置 [[Get]] 操作首先在对象中查找是否有名称相同的属性， 如果找到就会返回这个属性的值</li>
<li>[[Get]] 算法的定义会执行遍历可能存在的 [[Prototype]] 链 (第五章详细解释)</li>
</ol>
<h5 id="2-返回值"><a href="#2-返回值" class="headerlink" title="[2] 返回值"></a>[2] 返回值</h5><ul>
<li>无论如何都没有找到名称相同的属性，那 [[Get]] 操作会返回值 undefined</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; </span><br><span class="line">	a:<span class="number">2</span>&#125;;myObject.b; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意，这种方法和访问变量时是不一样的</li>
</ul>
<p>词法作用域中不存在的变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// Uncaught ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>
<p>对象查找不到属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; </span><br><span class="line">	a:<span class="number">2</span>&#125;;myObject.b; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<ul>
<li>[[Get]] 操作对 myObject.b 进行了更复杂的处理</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; </span><br><span class="line">	a: <span class="literal">undefined</span>&#125;;myObject.a; <span class="comment">// undefined</span>myObject.b; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>由于仅根据返回值无法判断出到底变量的值为 undefined 还是变量不存在，所以 [[Get]] 操作返回了 undefined。</p>
<h4 id="9-PUT"><a href="#9-PUT" class="headerlink" title="(9) [[PUT]]"></a>(9) [[PUT]]</h4><p>[[Put]] 被触发时，实际的行为取决于许多因素，包括对象中是否已经存在这个属性</p>
<p>如果已经存在这个属性，[[Put]] 算法大致会检查下面这些内容。</p>
<ol>
<li>属性是否是访问描述符(参见3.3.9节)如果是并且存在setter就调用setter。</li>
<li>属性的数据描述符中writable是否是false?如果是，在非严格模式下静默失败，在<br>严格模式下抛出 TypeError 异常。</li>
<li>如果都不是，将该值设置为属性的值。</li>
</ol>
<p>如果对象中不存在这个属性，[[Put]] 操作会更加复杂。我们会在第 5 章讨论 [[Prototype]] 时详细进行介绍。</p>
<h4 id="10-Getter和Setter"><a href="#10-Getter和Setter" class="headerlink" title="(10) Getter和Setter"></a>(10) Getter和Setter</h4><h5 id="1-Getter"><a href="#1-Getter" class="headerlink" title="[1] Getter"></a>[1] Getter</h5><p>当你给一个属性定义 getter、setter 或者两者都有时，这个属性会被定义为“访问描述 符”(和“数据描述符”相对)</p>
<p>对象默认的 [[Put]] 和 [[Get]] 操作分别可以控制属性值的设置和获取。</p>
<ul>
<li>在 ES5 中可以使用 getter 和 setter 部分改写默认操作，但是只能应用在单个属性上，无法 应用在整个对象上。</li>
<li>getter 是一个隐藏函数，会在获取属性值时调用。setter 也是一个隐藏 函数，会在设置属性值时调用。</li>
<li>对于访问描述符来说，会<strong>忽略它们的 value 和 writable 特性</strong>，关心 set 和 get(还有 configurable 和 enumerable)特性。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 形式1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  get a() &#123;</span><br><span class="line">   	<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 形式2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty( obj, <span class="string">'b'</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">3</span> &#125;,</span><br><span class="line">  	enumerable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"> );</span><br><span class="line"></span><br><span class="line">obj.a = <span class="string">'666'</span>; <span class="comment">//readonly</span></span><br><span class="line">obj.b = <span class="string">'666'</span>; <span class="comment">//readonly</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.a); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.b); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<p>不管是对象文字语法中的get a() { .. }，还是defineProperty(..)中的显式定义，二者 都会在对象中创建一个不包含值的属性，对于这个属性的访问会自动调用一个隐藏函数， 它的返回值会被当作属性访问的返回值:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;<span class="comment">// 给 a 定义一个 </span></span><br><span class="line">	getter get a() &#123;		<span class="keyword">return</span> <span class="number">2</span>; </span><br><span class="line">	&#125;;myObject.a = <span class="number">3</span>;myObject.a; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>由于我们只定义了 a 的 getter，所以对 a 的值进行设置时 set 操作会忽略赋值操作，不会抛 出错误。而且即便有合法的 setter，由于我们自定义的 getter 只会返回 2，所以 set 操作是 没有意义的。</p>
<h5 id="2-Setter"><a href="#2-Setter" class="headerlink" title="[2] Setter"></a>[2] Setter</h5><p>setter 会覆盖单个属性默认的 [[Put]](也被称为赋值)操作。<strong>通常来说 getter 和 setter 是成对出现的</strong>(只定义一个的话 通常会产生意料之外的行为):</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> obj = &#123;</span><br><span class="line">   get a() &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>._a</span><br><span class="line">   &#125;,</span><br><span class="line">   set a(val) &#123;</span><br><span class="line">      	<span class="keyword">this</span>._a = val * <span class="number">100</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.a);  <span class="comment">// 200</span></span><br></pre></td></tr></table></figure>
<p>在本例中，实际上我们把赋值([[Put]])操作中的值 2 存储到了另一个变量 _a_ 中。名称 _a_ 只是一种惯例，没有任何特殊的行为——和其他普通属性一样。</p>
<h4 id="11-存在性"><a href="#11-存在性" class="headerlink" title="(11) 存在性"></a>(11) 存在性</h4><p>如 myObject.a 的属性访问返回值可能是 undefined，但是这个值有可能 是属性中存储的 undefined，也可能是因为属性不存在所以返回 undefined。那么如何区分 这两种情况呢?</p>
<ul>
<li>不访问属性值的情况下判断对象中是否存在这个属性:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"a"</span> <span class="keyword">in</span> myObject); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"b"</span> <span class="keyword">in</span> myObject); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(myObject.hasOwnProperty( <span class="string">"a"</span> )); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(myObject.hasOwnProperty( <span class="string">"b"</span> )); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<ul>
<li>in操作符：检查属性是否在对象及其 [[Prototype]] 原型链中</li>
<li><p>hasOwnProperty： 只会检查属性是否在 myObject 对象中，不会检查 [[Prototype]] 链</p>
</li>
<li><p>所有的普通对象都可以通过对于 Object.prototype 的委托(参见第 5 章)来访问 hasOwnProperty(..)，但是有的对象可能没有连接到 Object.prototype(通过 Object. create(null) 来创建——参见第 5 章)。在这种情况下，形如 myObejct.hasOwnProperty(..) 就会失败。</p>
</li>
<li><p>这时可以使用一种更加强硬的方法来进行判断:Object.prototype.hasOwnProperty. call(myObject,”a”)，它借用基础的 hasOwnProperty(..) 方法并把它显式绑定(参见第 2 章)到 myObject 上。</p>
</li>
<li><p>看起来 in 操作符可以检查容器内是否有某个值，但是它实际上检查的是某 个属性名是否存在。对于数组来说这个区别非常重要，4 in [2, 4, 6]的结 果并不是你期待的 True，因为 [2, 4, 6] 这个数组中包含的属性名是 0、1、 2，没有 4。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]); <span class="comment">//Array 属性名 0 1 2 3 因此false</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="1-枚举"><a href="#1-枚举" class="headerlink" title="[1] 枚举"></a>[1] 枚举</h5><ul>
<li>什么是“可枚举性”：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123; &#125;;</span><br><span class="line">Object.defineProperty(myObject, &quot;a&quot;);</span><br><span class="line">Object.defineProperty(myObject, &quot;b&quot;, &#123; enumerable: false, value: 3 &#125;);</span><br><span class="line"></span><br><span class="line">console.log(myObject.b); // 3</span><br><span class="line"></span><br><span class="line">console.log((&quot;b&quot; in myObject)); // true</span><br><span class="line"></span><br><span class="line">myObject.hasOwnProperty( &quot;b&quot; ); // true</span><br><span class="line"></span><br><span class="line">for (var k in myObject) &#123;</span><br><span class="line">  console.log( k, myObject[k] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>myObject.b 确实存在并且有访问值，但是却不会出现在 for..in 循环中(尽管 可以通过 in 操作符来判断是否存在),<strong>原因是“可枚举”就相当于“可以出现在对象属性 的遍历中”。</strong></p>
<ul>
<li><p>在数组上应用 for..in 循环有时会产生出人意料的结果，因为这种枚举不 仅会包含所有数值索引，还会包含所有可枚举属性。最好只在对象上应用 for..in 循环，如果要遍历数组就使用传统的 for 循环来遍历数值索引。</p>
</li>
<li><p>其他方法区分属性是否可枚举：</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; &#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myObject, <span class="string">"a"</span>, &#123; <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="number">2</span> &#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myObject,<span class="string">"b"</span>,&#123; <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="number">3</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myObject.propertyIsEnumerable( <span class="string">"a"</span> )); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(myObject.propertyIsEnumerable( <span class="string">"b"</span> )); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys( myObject )); <span class="comment">// ["a"]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames( myObject )); <span class="comment">// ["a", "b"]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>propertyIsEnumerable(..) 会检查给定的属性名<strong>是否直接存在于对象中(而不是在原型链上)</strong>并且满足 enumerable:true。</li>
<li>Object.keys(..) 会返回一个数组，包含所有可枚举属性，Object.getOwnPropertyNames(..) 会返回一个数组，包含所有属性，无论它们是否可枚举。</li>
<li>in 和 hasOwnProperty(..) 的区别在于是否查找 [[Prototype]] 链，然而，Object.keys(..) 和 Object.getOwnPropertyNames(..) 都只会查找对象直接包含的属性。</li>
<li>(目前)并没有内置的方法可以获取 in 操作符使用的属性列表(对象本身的属性以 及 [[Prototype]] 链中的所有属性，参见第 5 章)。不过你可以递归遍历某个对象的整条 [[Prototype]] 链并保存每一层中使用 Object.keys(..) 得到的属性列表——只包含可枚举属性。</li>
</ul>
<h3 id="3-遍历"><a href="#3-遍历" class="headerlink" title="3.遍历"></a>3.遍历</h3><p>for..in 循环可以用来遍历对象的可枚举属性列表(包括 [[Prototype]] 链)。但是如何遍<br>历属性的值呢?</p>
<ul>
<li>对于数值索引的数组来说，可以使用标准的 for 循环来遍历值:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; myArray.length; i++) &#123; </span><br><span class="line">	<span class="built_in">console</span>.log( myArray[i] ); <span class="comment">// 1 2 3</span>&#125;</span><br></pre></td></tr></table></figure>
<p>这实际上并不是在遍历值，而是遍历下标来指向值，如 myArray[i]。</p>
<h5 id="1-迭代方法："><a href="#1-迭代方法：" class="headerlink" title="[1] 迭代方法："></a>[1] 迭代方法：</h5><p>ES5 中增加了一些数组的辅助迭代器，包括 forEach(..)、every(..) 和 some(..)。每种辅 助迭代器都可以接受一个回调函数并把它应用到数组的每个元素上，唯一的区别就是它们 对于回调函数返回值的处理方式不同。</p>
<p>every(..) 和 some(..) 中特殊的返回值和普通 for 循环中的 break 语句类似，它们会提前 终止遍历。</p>
<ul>
<li><p>forEach</p>
<p>  forEach(..) 会遍历数组中的所有值并忽略回调函数的返回值。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">a.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value,index, arr</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);  <span class="comment">// 1 2 3</span></span><br><span class="line">    <span class="built_in">console</span>.log(index); <span class="comment">// 0 1 2</span></span><br><span class="line">    <span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>every</p>
<ul>
<li><p>every(..) 会一直运行直到回调函数返回 false(或者“假”值)</p>
</li>
<li><p>如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。</p>
</li>
<li><p>如果所有元素都满足条件，则返回 true。</p>
<p>  <strong>注意：</strong> every() 不会对空数组进行检测。</p>
<p>  <strong>注意：</strong> every() 不会改变原始数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.every(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue,index,arr</span>), <span class="title">thisValue</span>);</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<pre><code>例子：

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> res = a.every(<span class="function"><span class="keyword">function</span>(<span class="params">value,index, arr</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> value &gt; <span class="number">0</span>;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log(res); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li><p>some</p>
<p>  some(..) 会一直运行直到回调函数返回 true(或者 “真”值)。</p>
<ul>
<li>如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。</li>
<li><p>如果没有满足条件的元素，则返回false。</p>
<p>  注意： some() 不会对空数组进行检测。</p>
<p>  注意： some() 不会改变原始数组。</p>
</li>
</ul>
</li>
</ul>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.some(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue,index,arr</span>),<span class="title">thisValue</span>)</span></span><br></pre></td></tr></table></figure>

例子：

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> res = a.some(<span class="function"><span class="keyword">function</span>(<span class="params">value,index, arr</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> value &lt; <span class="number">1</span>;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log(res); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li><p>for in</p>
<p>  使用 for..in 遍历对象是无法直接获取属性值的，因为它实际上遍历的是对象中的所有可枚举属性，你需要手动获取属性值。</p>
</li>
<li><p><strong>for of</strong></p>
<p>  那么如何直接遍历值而不是数组下标(或者对象属性)呢?幸好，ES6 增加了一种用来遍 历数组的 for..of 循环语法(如果对象本身定义了迭代器的话也可以遍历对象):</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArray = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ];<span class="keyword">for</span> (<span class="keyword">var</span> v <span class="keyword">of</span> myArray) &#123; </span><br><span class="line">	<span class="built_in">console</span>.log( v ); <span class="comment">// 1 // 2 // 3</span>&#125;</span><br><span class="line"><span class="string">``</span><span class="string">`- for..of 循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的 next() 方法来遍历所有返回值。</span></span><br><span class="line"><span class="string">- 数组有内置的 @@iterator，因此 for..of 可以直接应用在数组上。我们使用内置的 @@ iterator 来手动遍历数组，看看它是怎么工作的:	</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="keyword">var</span> myArray = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ];<span class="keyword">var</span> it = myArray[<span class="built_in">Symbol</span>.iterator]();it.next(); <span class="comment">// &#123; value:1, done:false &#125; </span></span><br><span class="line">it.next(); <span class="comment">// &#123; value:2, done:false &#125; </span></span><br><span class="line">it.next(); <span class="comment">// &#123; value:3, done:false &#125; </span></span><br><span class="line">it.next(); <span class="comment">// &#123; done:true &#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>调用迭代器的 next() 方法会返回形式为 { value: .. , done: .. } 的值， value 是当前的遍历值，done 是一个布尔值，表示是否还有可以遍历的值。</li>
<li>和值“3”一起返回的是 done:false，乍一看好像很奇怪，你必须再调用一次 next() 才能得到 done:true，从而确定完成遍历。这个机制和 ES6 中发生器函数的语义相 关，不过已经超出了我们的讨论范围。</li>
<li>和数组不同，普通的对象没有内置的 @@iterator，所以无法自动完成 for..of 遍历。之所 以要这样做，有许多非常复杂的原因，不过简单来说，这样做是为了避免影响未来的对象 类型。</li>
</ul>
<p>当然，你可以给任何想遍历的对象定义 @@iterator，举例来说:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    b: <span class="number">3</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">Object</span>.defineProperty( myObject, <span class="built_in">Symbol</span>.iterator, &#123; </span><br><span class="line"> 	enumerable: <span class="literal">false</span>,</span><br><span class="line">   writable: <span class="literal">false</span>,</span><br><span class="line">   configurable: <span class="literal">true</span>,</span><br><span class="line">   value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">   		<span class="keyword">var</span> o = <span class="keyword">this</span>;</span><br><span class="line">       <span class="keyword">var</span> idx = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">var</span> ks = <span class="built_in">Object</span>.keys( o ); </span><br><span class="line">       <span class="keyword">return</span> &#123;</span><br><span class="line">          next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> &#123;</span><br><span class="line">           value: o[ks[idx++]],</span><br><span class="line">           done: (idx &gt; ks.length)</span><br><span class="line">        &#125;;</span><br><span class="line">      	&#125; </span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动遍历 myObject</span></span><br><span class="line"><span class="keyword">var</span> it = myObject[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">it.next(); <span class="comment">// &#123; value:2, done:false &#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123; value:3, done:false &#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123; value:undefined, done:true &#125;</span></span><br><span class="line"><span class="comment">// 用 for..of 遍历 myObject</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> v <span class="keyword">of</span> myObject) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log( v );     <span class="comment">// 2 // 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>for..of 循环每次调用 myObject 迭代器对象的 next() 方法时，内部的指针都会向前移动并 返回对象属性列表的下一个值(再次提醒，需要注意遍历对象属性 / 值时的顺序)。</li>
</ul>
<ul>
<li>代码中的遍历非常简单，只是传递了属性本身的值。不过只要你愿意，当然也可以在自定 义的数据结构上实现各种复杂的遍历。</li>
</ul>
<p>无限”迭代器例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> randoms = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="built_in">Math</span>.random() &#125;; &#125;</span><br><span class="line">    &#125;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> randoms_pool = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> n <span class="keyword">of</span> randoms) &#123;</span><br><span class="line">  randoms_pool.push( n );</span><br><span class="line">  <span class="comment">// 防止无限运行!</span></span><br><span class="line">  <span class="keyword">if</span> (randoms_pool.length === <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(randoms_pool);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个迭代器会生成“无限个”随机数，因此我们添加了一条 break 语句，防止程序被挂起。</p>
<p><strong>ps. 补充知识（关于Symbol.iterator）</strong></p>
<p>我们使用 ES6 中的符号 Symbol.iterator 来获取对象的 @@iterator 内部属 性。之前我们简单介绍过符号(Symbol，参见 3.3.1 节)，跟这里的原理是相 同的。引用类似 iterator 的特殊属性时要使用符号名，而不是符号包含的 值。此外，虽然看起来很像一个对象，但是 @@iterator 本身并不是一个迭代 器对象，而是一个返回迭代器对象的函数——这点非常精妙并且非常重要。</p>
<p>遍历数组下标时采用的是数字顺序(for 循环或者其他迭代器)，但是遍历对 象属性时的顺序是不确定的，在不同的 JavaScript 引擎中可能不一样。因此， 在不同的环境中需要保证一致性时，一定不要相信任何观察到的顺序，它们 是不可靠的。</p>
<h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h3><h4 id="1-定义对象的方式"><a href="#1-定义对象的方式" class="headerlink" title="(1)定义对象的方式"></a>(1)定义对象的方式</h4><ul>
<li>字面量 （更常用）</li>
<li>构造函数 （提供更多选项）</li>
</ul>
<h4 id="2-对象的类型"><a href="#2-对象的类型" class="headerlink" title="(2)对象的类型"></a>(2)对象的类型</h4><ul>
<li>对象是引用数据类型</li>
<li>对象有包括 function 在内的子类型，不同子类型具有不同 的行为，比如内部标签[object Array]表示这是对象的子类型数组。</li>
</ul>
<h4 id="3-对象的属性"><a href="#3-对象的属性" class="headerlink" title="(3)对象的属性"></a>(3)对象的属性</h4><ul>
<li>对象就是键 / 值对的集合</li>
<li>propName 或者 [“propName”] 语法来获取属性值</li>
<li><p>访问属性时，引擎实际上会调用内部的默认 [[Get]] 操作(在设置属性值时是 [[Put]])， [[Get]] 操作会检查对象本身是否包含这个属性，如果没找到的话还会查找 [[Prototype]] 链(参见第 5 章)。</p>
</li>
<li><p>属性的特性可以通过属性描述符来控制，比如 writable 和 configurable。</p>
</li>
<li>可以使用 Object.preventExtensions(..)、Object.seal(..) 和 Object.freeze(..) 来设置对象(及其 属性)的不可变性级别。</li>
<li>属性不一定包含值——它们可能是具备 getter/setter 的“访问描述符”。</li>
<li>属性可以是 可枚举或者不可枚举的，这决定了它们是否会出现在 for..in 循环中。</li>
</ul>
<h4 id="4-对象的遍历"><a href="#4-对象的遍历" class="headerlink" title="(4)对象的遍历"></a>(4)对象的遍历</h4><ul>
<li>ES6 的 for..of 语法来遍历数据结构(数组、对象，等等)中的值，for..of 会寻找内置或者自定义的 @@iterator 对象并调用它的 next() 方法来遍历数据值。</li>
</ul>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://www.neohuang.com/child/2018/09/29/not-know-js-review-object/" data-id="cjmn644zr000nfhm7sjlahgqe" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            <!--
    
        <a href="http://www.neohuang.com/child/2018/09/29/not-know-js-review-object/#comments" class="article-comment-link">Comments</a>
    
-->
        </footer>
    </div>
    
        
<nav id="article-nav">
    
    
        <a href="/2018/09/29/not-know-js-review-class/" id="article-nav-older" class="article-nav-link-wrap">
            <strong class="article-nav-caption">Older</strong>
            <div class="article-nav-title">你不知道的js复习笔记 (混合对象“类”)</div>
        </a>
    
</nav>


    
</article>


    
    <section id="comments">
    
        
    <div id="uyan_frame"></div>

    
    </section>

</section>
            
                <aside id="sidebar">
   
        
    <div class="widget-wrap">
        <h3 class="widget-title">recent</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/09/29/not-know-js-review-object/" class="thumbnail">
    
    
        <span style="background-image:url(/img/not-know-js-review.jpeg)" alt="你不知道的js复习笔记 (对象)" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2018/09/29/not-know-js-review-object/" class="title">你不知道的js复习笔记 (对象)</a></p>
                            <p class="item-date"><time datetime="2018-09-28T16:00:00.000Z" itemprop="datePublished">2018-09-29</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/09/29/not-know-js-review-class/" class="thumbnail">
    
    
        <span style="background-image:url(/img/not-know-js-review.jpeg)" alt="你不知道的js复习笔记 (混合对象“类”)" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2018/09/29/not-know-js-review-class/" class="title">你不知道的js复习笔记 (混合对象“类”)</a></p>
                            <p class="item-date"><time datetime="2018-09-28T16:00:00.000Z" itemprop="datePublished">2018-09-29</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/09/25/not-know-js-review-this/" class="thumbnail">
    
    
        <span style="background-image:url(/img/not-know-js-review.jpeg)" alt="你不知道的js复习笔记 (this)" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2018/09/25/not-know-js-review-this/" class="title">你不知道的js复习笔记 (this)</a></p>
                            <p class="item-date"><time datetime="2018-09-24T16:00:00.000Z" itemprop="datePublished">2018-09-25</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/09/19/not-know-js-review-closure/" class="thumbnail">
    
    
        <span style="background-image:url(/img/not-know-js-review.jpeg)" alt="你不知道的js复习笔记 (作用域闭包)" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2018/09/19/not-know-js-review-closure/" class="title">你不知道的js复习笔记 (作用域闭包)</a></p>
                            <p class="item-date"><time datetime="2018-09-18T16:00:00.000Z" itemprop="datePublished">2018-09-19</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/09/13/not-know-js-review-fp-scope-block-scope/" class="thumbnail">
    
    
        <span style="background-image:url(/img/not-know-js-review.jpeg)" alt="你不知道的js复习笔记 (词法作用域)" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2018/09/13/not-know-js-review-fp-scope-block-scope/" class="title">你不知道的js复习笔记 (词法作用域)</a></p>
                            <p class="item-date"><time datetime="2018-09-12T16:00:00.000Z" itemprop="datePublished">2018-09-13</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

    
        
    
        
    <div class="widget-wrap">
        <h3 class="widget-title">archives</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a><span class="archive-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    
        
    
        
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">links</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="http://blog.zhaiyifan.cn/">MarkZhai</a>
                    </li>
                
                    <li>
                        <a href="http://silverd.cn/">SilverdJiang</a>
                    </li>
                
                    <li>
                        <a href="http://yownyang.github.io">YownYang</a>
                    </li>
                
                    <li>
                        <a href="http://zhukejin.com">PrimoZhu</a>
                    </li>
                
                    <li>
                        <a href="http://wjerryzhen11.github.io">JerryXu</a>
                    </li>
                
                    <li>
                        <a href="http://yocann.cn">CnnyChen</a>
                    </li>
                
            </ul>
        </div>
    </div>


    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
            
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2018 Neo<br>
            Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="http://github.com/ppoffice">PPOffice</a>
        </div>
    </div>
</footer>
        
    
    <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2131605"></script>




    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>