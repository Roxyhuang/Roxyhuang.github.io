<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    
    <title>Neo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta property="og:type" content="website">
<meta property="og:title" content="Neo">
<meta property="og:url" content="http://www.neohuang.com/child/index.html">
<meta property="og:site_name" content="Neo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Neo">
    

    

    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
    
    


</head>

<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <!--<span class="site-title">Neo</span>-->
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/.">Home</a>
                
                    <a class="main-nav-link" href="/archives">Archives</a>
                
            </nav>
            
                
                <nav id="sub-nav">
                    <div class="profile" id="profile-nav">
                        <a id="profile-anchor" href="javascript:;">
                            <img class="avatar" src="/css/images/doge.jpeg" />
                            <i class="fa fa-caret-down"></i>
                        </a>
                    </div>
                </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Buscar" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Entradas',
            PAGES: 'Pages',
            CATEGORIES: 'Categorias',
            TAGS: 'Etiquetas',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/.">Home</a></td>
                
                    <td><a class="main-nav-link" href="/archives">Archives</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Buscar" />
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
                

<aside id="profile">
    <div class="inner profile-inner">
        <div class="base-info profile-block">
            <img id="avatar" src="/css/images/doge.jpeg" />
            <h2 id="name">Neo Huang</h2>
            <h3 id="title">Front End Developer</h3>
            <span id="location"><i class="fa fa-map-marker"></i>Shanghai, China</span>
            <a id="follow" target="_blank" href="https://github.com/Roxyhuang">SEGUIR</a>
        </div>
        <div class="article-info profile-block">
            <div class="article-info-block">
                25
                <span>Entradas</span>
            </div>
            <div class="article-info-block">
                0
                <span>Etiqueta</span>
            </div>
        </div>
        
        <div class="profile-block social-links">
            <table>
                <tr>
                    
                    
                    <td>
                        <a href="https://github.com/Roxyhuang" target="_blank" title="github" class=tooltip>
                            <i class="fa fa-github"></i>
                        </a>
                    </td>
                    
                </tr>
            </table>
        </div>
        
    </div>
</aside>

            
            <section id="main">
    <article id="post-not-know-js-review-object" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2018/09/29/not-know-js-review-object/">你不知道的js复习笔记 (对象)</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2018/09/29/not-know-js-review-object/">
            <time datetime="2018-09-28T16:00:00.000Z" itemprop="datePublished">2018-09-29</time>
        </a>
    </div>


                        
                        
                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h2 id="一-语法"><a href="#一-语法" class="headerlink" title="一. 语法"></a>一. 语法</h2><p>对象可以通过两种形式定义:字面量和构造形式</p>
<h3 id="1-字面量"><a href="#1-字面量" class="headerlink" title="1. 字面量"></a>1. 字面量</h3><p>常用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123; </span><br><span class="line">	key: value,	<span class="comment">// ... </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-构造形式"><a href="#2-构造形式" class="headerlink" title="2. 构造形式"></a>2. 构造形式</h3><p>不常用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">myObj.key = value;</span><br></pre></td></tr></table></figure>
<p><strong>区别</strong>是，在文字声明中你可以添加多个 键 / 值对，但是在构造形式中你必须逐个添加属性。</p>
<h3 id="2-类型"><a href="#2-类型" class="headerlink" title="2. 类型"></a>2. 类型</h3><p>对象是 JavaScript 的基础。在 JavaScript 中一共有六种主要类型(术语是“语言类型”):</p>
<ul>
<li>string </li>
<li>number </li>
<li>boolean </li>
<li>null</li>
<li>undefined </li>
<li>object</li>
</ul>
<h4 id="1-简单数据类型的一些注意"><a href="#1-简单数据类型的一些注意" class="headerlink" title="(1)简单数据类型的一些注意"></a>(1)简单数据类型的一些注意</h4><p><strong>注意</strong>，简单基本类型(string、boolean、number、null 和 undefined)本身并不是对象。 null 有时会被当作一种对象类型，但是这其实只是语言本身的一个 bug，即对 null 执行 typeof null时会返回字符串”object”。1实际上，null本身是基本类型。</p>
<p>JavaScript 中万物皆是对象”，这显然是<strong>错误</strong>的。</p>
<h4 id="2-复杂数据类型的一些注意"><a href="#2-复杂数据类型的一些注意" class="headerlink" title="(2)复杂数据类型的一些注意"></a>(2)复杂数据类型的一些注意</h4><p>JavaScript 中有许多特殊的对象子类型，我们可以称之为复杂基本类型。</p>
<ul>
<li><p>函数就是对象的一个子类型(从技术角度来说就是“可调用的对象”)。</p>
<p>  JavaScript 中的函数是“一等公民”，因为它们本质上和普通的对象一样(只是可以调用)，所以可以像操作 其他对象一样操作函数(比如当作另一个函数的参数)。</p>
</li>
<li><p>数组也是对象的一种类型，具备一些额外的行为。数组中内容的组织方式比一般的对象要 稍微复杂一些。</p>
</li>
</ul>
<h4 id="3-内置对象"><a href="#3-内置对象" class="headerlink" title="(3)内置对象"></a>(3)内置对象</h4><p>JavaScript 中还有一些对象子类型，通常被称为内置对象。有些内置对象的名字看起来和 简单基础类型一样</p>
<ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Object</li>
<li>Function</li>
<li>Array</li>
<li>Date</li>
<li>RegExp</li>
<li>Error</li>
</ul>
<p>这些内置对象从表现形式来说很像其他语言中的类型(type)或者类(class)，比如 Java 中的 String 类。</p>
<p>但是在 JavaScript 中，它们实际上只是一些内置函数。这些内置函数可以当作构造函数 (由 new 产生的函数调用——参见第 2 章)来使用，从而可以构造一个对应子类型的新对象。举例来说:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strPrimitive = <span class="string">"I am a string"</span>; <span class="keyword">typeof</span> strPrimitive; <span class="comment">// "string" strPrimitive instanceof String; // false</span><span class="keyword">var</span> strObject = <span class="keyword">new</span> <span class="built_in">String</span>( <span class="string">"I am a string"</span> ); </span><br><span class="line"><span class="keyword">typeof</span> strObject; <span class="comment">// "object"</span>strObject <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">// true</span><span class="comment">// 检查 sub-type 对象</span><span class="built_in">Object</span>.prototype.toString.call( strObject ); <span class="comment">// [object String]</span></span><br></pre></td></tr></table></figure>
<p>暂时不关心Object.prototype.toString的工作原理，我们可以认为子类型在内部借用了 Object 中的 toString() 方法。</p>
<p><strong>特别注意</strong></p>
<p>原始值 “I am a string” 并不是一个对象，它只是一个字面量，并且是一个不可变的值。如果要在这个字面量上执行一些操作，比如获取长度、访问其中某个字符等，那需要将其 转换为 String 对象。幸好，在必要时语言会自动把字符串字面量转换成一个 String 对象，也就是说你并不需要 显式创建一个对象。JavaScript 社区中的大多数人都认为能使用文字形式时就不要使用构 造形式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strPrimitive = <span class="string">"I am a string"</span>; </span><br><span class="line"><span class="comment">// 可以理解为 String(strPrimitive).length;</span></span><br><span class="line"><span class="built_in">console</span>.log( strPrimitive.length ); <span class="comment">// 13</span></span><br><span class="line"><span class="comment">// 可以理解为 String(strPrimitive).charAt( 3 );</span></span><br><span class="line"><span class="built_in">console</span>.log( strPrimitive.charAt( <span class="number">3</span> ) ); <span class="comment">// "m"</span></span><br></pre></td></tr></table></figure>
<p>使用以上两种方法，我们都可以直接在字符串字面量上访问属性或者方法，之所以可以这 样做，是因为引擎自动把字面量转换成 String 对象，所以可以访问属性和方法。</p>
<ul>
<li><strong>string、number以及boolean都同上。但null 和 undefined 没有对应的构造形式，它们只有文字形式。相反，Date 只有构造，没有文字形式。</strong></li>
<li>object、Array、Function 和 RegExp(正则表达式),无论使用文字形式还是构造形式,它们都是<strong>对象</strong>，不是<strong>字面量</strong>。在某些情况下，相比用文字形式创建对象，构造形 式可以提供一些额外选项。</li>
<li>Error 对象很少在代码中显式创建，一般是在抛出异常时被自动创建。也可以使用 new Error(..) 这种构造形式来创建，不过一般来说用不着。</li>
</ul>
<h3 id="3-内容"><a href="#3-内容" class="headerlink" title="3. 内容"></a>3. 内容</h3><p>对象的内容是由一些存储在特定命名位置的(任意类型的)值组成的，我们称之为属性。</p>
<p><strong>强调：</strong></p>
<p>在引擎内部，这些值的存储方式是多种多样的，一般并不会存 在对象容器内部。存储在对象容器内部的是这些属性的名称，它们就像指针(从技术角度 来说就是引用)一样，指向这些值真正的存储位置。</p>
<h4 id="1-属性访问"><a href="#1-属性访问" class="headerlink" title="(1)属性访问"></a>(1)属性访问</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; </span><br><span class="line">	a: <span class="number">2</span>&#125;;myObject.a; <span class="comment">// 2</span>myObject[<span class="string">"a"</span>]; <span class="comment">// 2</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">我们需要使用 . 操作符或者 [] 操作符来访问对象的属性，.a 语法通 常被称为“属性访问”，["a"] 语法通常被称为“键访问”。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">##### [1]两者的区别：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- . 操作符要求属性名满足标识符的命名规范</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">- 而 [".."] 语法 可以接受任意 UTF-8/Unicode 字符串作为属性名。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	`</span><span class="string">``</span>javascript</span><br><span class="line">	myObject[<span class="string">'Super- Fun!'</span>] <span class="comment">// 合法</span></span><br><span class="line">	myObject.Super-FUN! <span class="comment">// 不合法</span></span><br></pre></td></tr></table></figure>
<ul>
<li>由于 [“..”] 语法使用字符串来访问属性，所以可以在程序中构造这个字符串</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; </span><br><span class="line">	a:<span class="number">2</span>&#125;;<span class="keyword">var</span> idx;<span class="keyword">if</span> (wantA) &#123; </span><br><span class="line">	idx = <span class="string">"a"</span>;&#125;<span class="comment">// 之后</span><span class="built_in">console</span>.log( myObject[idx] ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>在对象中，属性名永远都是字符串。</strong>,如果你使用 string(字面量)以外的其他值作为属性 名，那它首先会被转换为一个字符串。即使是数字也不例外，虽然在数组下标中使用的的 确是数字，但是在对象属性名中数字会被转换成字符串，所以当心不要搞混对象和数组中 数字的用法:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;;myObject[<span class="literal">true</span>] = <span class="string">"foo"</span>; </span><br><span class="line">myObject[<span class="number">3</span>] = <span class="string">"bar"</span>; </span><br><span class="line">myObject[myObject] = <span class="string">"baz"</span>;myObject[<span class="string">"true"</span>]; <span class="comment">// "foo"</span>myObject[<span class="string">"3"</span>]; <span class="comment">// "bar"</span>myObject[<span class="string">"[object Object]"</span>]; <span class="comment">// "baz"</span></span><br></pre></td></tr></table></figure>
<h4 id="2-可计算属性名"><a href="#2-可计算属性名" class="headerlink" title="(2)可计算属性名"></a>(2)可计算属性名</h4><h5 id="1-可计算属性名"><a href="#1-可计算属性名" class="headerlink" title="[1] 可计算属性名"></a>[1] 可计算属性名</h5><p>实际是通过这种形式 myObject[prefix + name]，但是使用文字形式来声明对 象时这样做是不行的。</p>
<p>ES6 增加了可计算属性名，可以在文字形式中使用 [] 包裹一个表达式来当作属性名:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> prefix = <span class="string">"foo"</span>;<span class="keyword">var</span> myObject = &#123;	[prefix + <span class="string">"bar"</span>]:<span class="string">"hello"</span>, </span><br><span class="line">	[prefix + <span class="string">"baz"</span>]: <span class="string">"world"</span>&#125;;myObject[<span class="string">"foobar"</span>]; <span class="comment">// hello</span>myObject[<span class="string">"foobaz"</span>]; <span class="comment">// world</span></span><br></pre></td></tr></table></figure>
<h5 id="2-Symbol"><a href="#2-Symbol" class="headerlink" title="[2] Symbol"></a>[2] Symbol</h5><p>可计算属性名最常用的场景可能是 ES6 的符号(Symbol)，简单来说，它们是一种新的基础数据类型，包含一个不透明且无法预测的值(从技术角度来说就是一个字符串)。</p>
<p>一般来说你不会用到符号的实际值(因为理论上来说在不 同的 JavaScript 引擎中值是不同的)，所以通常你接触到的是符号的名称，比如 Symbol. Something(这个名字是我编的):</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;	[<span class="built_in">Symbol</span>.Something]: <span class="string">"hello world"</span>&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-属性与方法"><a href="#3-属性与方法" class="headerlink" title="[3] 属性与方法"></a>[3] 属性与方法</h5><p><strong>请不要在js中不要混淆函数和方法的概念</strong></p>
<p>如果访问的对象属性是一个函数,有些开发者喜欢使用不一样的叫法以作区分,由于函数 很容易被认为是属于某个对象，在其他语言中，属于对象(也被称为“类”)的函数通常 被称为“方法”，因此把“属性访问”说成是“方法访问”也就不奇怪了。</p>
<p>js中虽然也有类似规范，但不是从技术上来说不是特别准确。</p>
<p>有些函数具有 this 引用，有时候这些 this 确实会指向调用位置的对象引用。但是 这种用法从本质上来说并没有把一个函数变成一个“方法”，因为 this 是在运行时根据调 用位置动态绑定的，所以函数和对象的关系最多也只能说是间接关系。</p>
<p>无论返回值是什么类型，每次访问对象的属性就是属性访问。如果属性访问返回的是一个 函数，那它也并不是一个“方法”。属性访问返回的函数和其他函数没有任何区别(除了 可能发生的隐式绑定 this，就像我们刚才提到的)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">"foo"</span> );&#125;<span class="keyword">var</span> someFoo = foo; <span class="comment">//对foo的变量引用</span><span class="keyword">var</span> myObject = &#123; </span><br><span class="line">	someFoo: foo&#125;;foo; <span class="comment">// function foo()&#123;..&#125;</span>someFoo; <span class="comment">// function foo()&#123;..&#125; </span></span><br><span class="line">myObject.someFoo; <span class="comment">// function foo()&#123;..&#125;</span></span><br></pre></td></tr></table></figure>
<p>例子中foo全是指向同一个foo函数</p>
<p>someFoo 和 myObject.someFoo 只是对于同一个函数的不同引用，并不能说明这个函数是特别的或者“属于”某个对象。如果 foo() 定义时在内部有一个 this 引用，那这两个函数引用的<strong>唯一区别</strong>就是 myObject.someFoo 中的 this 会被隐式绑定到一个对象。<strong>无论哪种引用 形式都不能称之为“方法”</strong>。</p>
<p>或许有人会辩解说，函数并不是在定义时成为方法，而是在被调用时根据调用位置的不同 (是否具有上下文对象——详见第 2 章)成为方法。即便如此，这种说法仍然有些不妥。</p>
<p>因此最保险的说法可能是，“函数”和“方法”在 JavaScript 中是可以互换的。</p>
<p>ES6 增加了 super 引用，一般来说会被用在 class 中(参见附录 A)。super 的行为似乎更有理由把 super 绑定的函数称为“方法”。但是再说一次，这 些只是一些语义(和技术)上的微妙差别，本质是一样的。</p>
<p>即使你在对象的文字形式中声明一个函数表达式，这个函数也不会“属于”这个对象—— 它们只是对于相同函数对象的多个引用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;	<span class="attr">foo</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;       	<span class="built_in">console</span>.log( <span class="string">"foo"</span> );     	&#125;&#125;;<span class="keyword">var</span> someFoo = myObject.foo; </span><br><span class="line">someFoo; <span class="comment">// function foo()&#123;..&#125; </span></span><br><span class="line">myObject.foo; <span class="comment">// function foo()&#123;..&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>ps:</strong>ES6 增加的一种 简易函数声明语法，属性声明语法。</p>
<h4 id="3-数组"><a href="#3-数组" class="headerlink" title="(3) 数组"></a>(3) 数组</h4><p>数组也支持 [] 访问形式，不过数组有一套更加结构化的值存储 机制(不过仍然不限制值的类型)</p>
<p>数组期望的是数值下标，也就是说值存储的位置。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArray = [ <span class="string">"foo"</span>, <span class="number">42</span>, <span class="string">"bar"</span> ]; </span><br><span class="line">myArray.length; <span class="comment">// 3</span>myArray[<span class="number">0</span>]; <span class="comment">// "foo"</span>myArray[<span class="number">2</span>]; <span class="comment">// "bar"</span></span><br></pre></td></tr></table></figure>
<p>数组也是对象，所以虽然每个下标都是整数，你仍然可以给数组添加属性:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var myArray = [ &quot;foo&quot;, 42, &quot;bar&quot; ];</span><br><span class="line">myArray.baz = &quot;baz&quot;;  // 会增加一个baz: &quot;baz&quot;</span><br><span class="line">myArray.length; // 3myArray.baz; // &quot;baz&quot;</span><br></pre></td></tr></table></figure>
<p><strong>需要注意：</strong>虽然添加了命名属性(无论是通过 . 语法还是 [] 语法)，数组的 length 值并未发 生变化。</p>
<p>你完全可以把数组当作一个普通的键 / 值对象来使用，并且不添加任何数值索引，但是这 并不是一个好主意。数组和普通的对象都根据其对应的行为和用途进行了优化（不建议）</p>
<p><strong>需要注意：</strong>:如果你试图向数组添加一个属性，但是属性名“看起来”像一个数字，那它会变成 一个数值下标(因此会修改数组的内容而不是添加一个属性):</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArray = [ <span class="string">"foo"</span>, <span class="number">42</span>, <span class="string">"bar"</span> ]; </span><br><span class="line">myArray[<span class="string">"3"</span>] = <span class="string">"baz"</span>;  <span class="comment">// 转化为了int 3</span></span><br><span class="line">myArray.length; <span class="comment">// 4</span>myArray[<span class="number">3</span>]; <span class="comment">// "baz"</span></span><br></pre></td></tr></table></figure>
<h4 id="4-复制对象"><a href="#4-复制对象" class="headerlink" title="(4) 复制对象"></a>(4) 复制对象</h4><p>这个问题上我们应需要考虑深拷贝和浅拷贝</p>
<p>从一个例子来分析</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">anotherFunction</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*..*/</span> &#125;<span class="keyword">var</span> anotherObject = &#123; </span><br><span class="line">	c: <span class="literal">true</span>&#125;;<span class="keyword">var</span> anotherArray = [];<span class="keyword">var</span> myObject = &#123; </span><br><span class="line">	a: <span class="number">2</span>,	<span class="attr">b</span>: anotherObject, <span class="comment">// 引用，不是复本! </span></span><br><span class="line">	c: anotherArray, <span class="comment">// 另一个引用!</span>	d: anotherFunction&#125;;</span><br><span class="line"></span><br><span class="line">anotherArray.push( anotherObject, myObject ); <span class="comment">// 很关键</span></span><br></pre></td></tr></table></figure>
<h5 id="1-浅拷贝"><a href="#1-浅拷贝" class="headerlink" title="[1] 浅拷贝"></a>[1] 浅拷贝</h5><p><strong>复制出的新对象时，基础数据类型会copy值，引用数据类型仅拷贝引用。</strong></p>
<p>复制出的新对象中 a 的值会 复制旧对象中 a 的值，也就是 2，但是新对象中 b、c、d 三个属性其实只是三个引用，它们 和旧对象中 b、c、d 引用的对象是一样的。</p>
<p>相比深复制，浅复制非常易懂并且问题要少得多，所以 ES6 定义了 Object.assign(..) 方 法来实现浅复制。</p>
<p>Object.assign(..) 方法的第一个参数是目标对象，之后还可以跟一个 或多个源对象。它会遍历一个或多个源对象的所有可枚举(enumerable，参见下面的代码) 的自有键(owned key，很快会介绍)并把它们复制(使用 = 操作符赋值)到目标对象，最 后返回目标对象，就像这样:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... myobject代码</span></span><br><span class="line"><span class="keyword">var</span> newObj = <span class="built_in">Object</span>.assign( &#123;&#125;, myObject );newObj.a; <span class="comment">// 2</span>newObj.b === anotherObject; <span class="comment">// true</span>newObj.c === anotherArray; <span class="comment">// true</span>newObj.d === anotherFunction; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>需要注意的一点是，由于 Object.assign(..) <strong>相当于使用 = 操作符来赋值</strong>，所 以源对象属性的<strong>一些特性(比如 writable)不会被复制到目标对象</strong>。</p>
<h5 id="2-深拷贝"><a href="#2-深拷贝" class="headerlink" title="[2] 深拷贝"></a>[2] 深拷贝</h5><p><strong>复制出的新对象时，基础数据类型复制新对象</strong></p>
<p>首先上面的例子不能用深拷贝，关键就是最后一句代码，因为了复制 myObject 以外还会复 制 anotherObject 和 anotherArray，这时问题就来了，anotherArray 引用了 anotherObject 和 myObject，所以又需要复制 myObject，这样就会由于循环引用导致死循环。</p>
<h5 id="3-为什么不能封装成一个统一方法"><a href="#3-为什么不能封装成一个统一方法" class="headerlink" title="[3] 为什么不能封装成一个统一方法"></a>[3] 为什么不能封装成一个统一方法</h5><p>其实根本问题就是在于深拷贝的一些不确定性</p>
<ul>
<li><p>出现循环引用导致死循环</p>
<p>  我们是应该检测循环引用并终止循环(不复制深层元素)?还是应当直接报错或者是选择 其他方法?</p>
</li>
<li><p>我们还不确定“复制”一个函数意味着什么</p>
<p>  有些人会通过 toString() 来序列 化一个函数的源代码(但是结果取决于 JavaScript 的具体实现，而且不同的引擎对于不同 类型的函数处理方式并不完全相同)。</p>
</li>
<li><p>是否能保证对象是 JSON 安全的，所以只适用于部分情况。</p>
<p>  对于 JSON 安全(也就是说可以被序列化为一个 JSON 字符串并且可以根据这个字符串解 析出一个结构和值完全一样的对象)的对象来说，有一种巧妙的复制方法:</p>
<p>  <code>`</code>javascript<br>  var newObj = JSON.parse( JSON.stringify( someObj ) );</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### (6) 属性描述符</span><br><span class="line"></span><br><span class="line">在 ES5 之前，JavaScript 语言本身并没有提供可以直接检测属性特性的方法，比如判断属性是否是只读。</span><br><span class="line">但是从 ES5 开始，所有的属性都具备了属性描述符。</span><br><span class="line"></span><br><span class="line">##### [1] 创建并使用</span><br><span class="line"></span><br><span class="line">在创建普通属性时属性描述符会使用默认值，我们也可以使用 Object.defineProperty(..) 来添加一个新属性或者修改一个已有属性(如果它是 configurable)并对特性进行设置。</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">var obj = &#123;</span><br><span class="line">    a: 2,</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">Object.getOwnPropertyDescriptor(obj,&apos;a&apos;);</span><br><span class="line">// &#123;// value: 2,// writable: true,// enumerable: true,// configurable: true // &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如你所见，这个普通的对象属性对应的属性描述符(也被称为“数据描述符”，因为它 只保存一个数据值)可不仅仅只是一个 2。</p>
<p>它还包含另外三个特性:</p>
<ul>
<li>writable(可写) </li>
<li>enumerable(可枚举)</li>
<li>configurable(可配置)。</li>
</ul>
<p>在创建普通属性时属性描述符会使用默认值，我们也可以使用 Object.defineProperty(..) 来添加一个新属性或者修改一个已有属性(如果它是 configurable)并对特性进行设置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"a"</span>, &#123;</span><br><span class="line">  value: <span class="number">2</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myObject.a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(myObject, <span class="string">'a'</span>))</span><br></pre></td></tr></table></figure>
<h5 id="2-Writable"><a href="#2-Writable" class="headerlink" title="[2] Writable"></a>[2] Writable</h5><p><strong>特征：</strong></p>
<p>当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false。(与delete无关)</p>
<p><strong>原理：</strong></p>
<p>你可以把 writable:false 看 作是属性不可改变，相当于你定义了一个空操作 setter。严格来说，如果要 和 writable:false 一致的话，你的 setter 被调用时应当抛出一个 TypeError 错误。</p>
<p><strong>例子：</strong></p>
<p>非严格模式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;;   <span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"a"</span>, &#123;      <span class="attr">value</span>: <span class="number">2</span>,		<span class="attr">writable</span>: <span class="literal">false</span>, <span class="comment">// 不可写! configurable: true, enumerable: true</span>   &#125; );myObject.a = <span class="number">3</span>;myObject.a; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>严格模式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"a"</span>, &#123;</span><br><span class="line">   value: <span class="number">2</span>,</span><br><span class="line">   writable: <span class="literal">false</span>, <span class="comment">// 不可写! configurable: true, enumerable: true</span></span><br><span class="line">&#125; );</span><br><span class="line">myObject.a = <span class="number">3</span>; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>
<p>TypeError 错误表示我们无法修改一个不可写的属性。</p>
<h5 id="3-Configurable"><a href="#3-Configurable" class="headerlink" title="[3] Configurable"></a>[3] Configurable</h5><p><strong>特征：</strong></p>
<ul>
<li>当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变<strong>(可以理解成能够使用 defineProperty(..) </strong></li>
<li><p>同时该属性也能从对应的对象上被删除。默认为 false。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">   a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line">myObject.a = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myObject.a);<span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"a"</span>, &#123;</span><br><span class="line">  value: <span class="number">4</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">false</span>, <span class="comment">// 不可配置!</span></span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myObject.a);<span class="comment">// 4</span></span><br><span class="line">myObject.a = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myObject.a); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"a"</span>, &#123;</span><br><span class="line">  value: <span class="number">6</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125; ); <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>
<p>  最后一个 defineProperty(..) 会产生一个 TypeError 错误，不管是不是处于严格模式，尝 试修改一个不可配置的属性描述符都会出错。注意:如你所见，把 configurable 修改成 false 是单向操作，无法撤销!</p>
</li>
<li><p>要注意有一个小小的例外:即便属性是 configurable:false，我们还是可以 把 writable 的状态由 true 改为 false，但是无法由 false 改为 true。</p>
</li>
<li><p>configurable:false 还会禁止删除这个属性</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">var</span> myObject = &#123; </span><br><span class="line">		a:<span class="number">2</span>&#125;;myObject.a; <span class="comment">// 2</span><span class="keyword">delete</span> myObject.a; </span><br><span class="line">	myObject.a; <span class="comment">// undefined</span><span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"a"</span>, &#123;  	<span class="attr">value</span>: <span class="number">2</span>,	<span class="attr">writable</span>: <span class="literal">true</span>, </span><br><span class="line">		configurable: <span class="literal">false</span>, </span><br><span class="line">		enumerable: <span class="literal">true</span>&#125; );myObject.a; <span class="comment">// 2 </span></span><br><span class="line">	<span class="keyword">delete</span> myObject.a; </span><br><span class="line">	myObject.a; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>最后一个 delete 语句(静默)失败了，因为属性是不可配置的。
</code></pre><ul>
<li>不要把 delete 看作一个释放内存的工具(就像 C/C++ 中那 样)，它就是一个删除对象属性的操作。        </li>
</ul>
<h5 id="4-Enumerable"><a href="#4-Enumerable" class="headerlink" title="[4] Enumerable"></a>[4] Enumerable</h5><p><strong>特征：</strong></p>
<p>这个描述符控制的是属性是否会出现在对象的属性枚举中</p>
<p>for..in 循环。如果把 enumerable 设置成 false，这个属性就不会出现在枚举中，虽然仍 然可以正常访问它。相对地，设置成 true 就会让它出现在枚举中。</p>
<p>用户定义的所有的普通属性默认都是 enumerable，这通常就是你想要的。但是如果你不希 望某些特殊属性出现在枚举中，那就把它设置成 enumerable:false。</p>
<p>// todos</p>
<h4 id="7-不变性"><a href="#7-不变性" class="headerlink" title="(7) 不变性"></a>(7) 不变性</h4><p>所有的方法创建的都是浅不变形，也就是说，它们只会影响目标对象和 它的直接属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myImmutableObject 设置不可变</span></span><br><span class="line">myImmutableObject.foo; <span class="comment">// [1,2,3]</span>myImmutableObject.foo.push( <span class="number">4</span> );myImmutableObject.foo; <span class="comment">// [1,2,3,4] // foo属性仍可变</span></span><br></pre></td></tr></table></figure>
<p>myImmutableObject 已经被创建而且是不可变的，但是为了保护它的内容 myImmutableObject.foo，你还需要使用下面的方法让 foo 也不可变。</p>
<h5 id="1-对象常量"><a href="#1-对象常量" class="headerlink" title="[1]对象常量"></a>[1]对象常量</h5><p>结合 writable:false 和 configurable:false 就可以创建一个真正的常量属性(不可修改、 重定义或者删除):</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;;<span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"FAVORITE_NUMBER"</span>, &#123;   <span class="attr">value</span>: <span class="number">42</span>,	<span class="attr">writable</span>: <span class="literal">false</span>,	<span class="attr">configurable</span>: <span class="literal">false</span> </span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<h5 id="2-禁止扩展"><a href="#2-禁止扩展" class="headerlink" title="[2]禁止扩展"></a>[2]禁止扩展</h5><p>如果你想禁止一个<strong>对象添加新属性并且保留已有属性</strong>，可以使用 Object.prevent Extensions(..):</p>
<ul>
<li>仅不能添加属性</li>
<li>可用等号赋值属性</li>
<li>可用delete删除属性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; <span class="attr">a</span>:<span class="number">2</span> &#125;;<span class="built_in">Object</span>.preventExtensions( myObject );myObject.b = <span class="number">3</span>;myObject.b; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>在非严格模式下，创建属性 b 会静默失败。在严格模式下，将会抛出 TypeError 错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; <span class="attr">a</span>:<span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions( myObject );</span><br><span class="line">myObject.b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">delete</span> myObject.a;</span><br><span class="line"><span class="built_in">console</span>.log(myObject);</span><br></pre></td></tr></table></figure>
<p><strong>delete仍有效</strong></p>
<h5 id="3-密封"><a href="#3-密封" class="headerlink" title="[3] 密封"></a>[3] 密封</h5><p>Object.seal(..) 会创建一个“密封”的<strong>对象</strong>，这个方法实际上会在一个现有对象上调用 Object.preventExtensions(..) 并把所有现有属性标记为 configurable:false。<br>所以，密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性(虽然可以 修改属性的值)。</p>
<p>Object.seal(..):</p>
<ul>
<li>所有属性configurable:false</li>
<li>可用等号赋值属性</li>
<li>密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    prop: <span class="number">42</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.seal(obj);</span><br><span class="line"></span><br><span class="line">obj.prop = <span class="number">36</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.prop);<span class="comment">// 36</span></span><br><span class="line"></span><br><span class="line">obj.prop2 = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// obj: &#123;props: 22 &#125; 未添加成功</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.prop;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// obj: &#123;props: 22 &#125; 未删除成功</span></span><br></pre></td></tr></table></figure>
<h5 id="4-冻结"><a href="#4-冻结" class="headerlink" title="[4] 冻结"></a>[4] 冻结</h5><p>Object.freeze(..) 会创建一个冻结对象，这个方法实际上会在一个现有对象上调用 Object.seal(..) 并把所有“数据访问”属性标记为 writable:false，这样就无法修改它们 的值。</p>
<ul>
<li>创建一个冻结对象</li>
<li>不可复制属性，也不可添加，删除属性</li>
<li>最高的不可变性</li>
<li>对象引用的其他对象是不受影响的</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> obj = &#123;</span><br><span class="line">    prop: <span class="number">42</span>,</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.freeze(obj);</span><br><span class="line"></span><br><span class="line">obj.prop = <span class="number">36</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.prop);<span class="comment">// 42</span></span><br><span class="line"></span><br><span class="line">obj.prop2 = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// obj: &#123;props: 42 &#125; 未添加成功</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.prop;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// obj: &#123;props: 42 &#125; 未删除成功</span></span><br></pre></td></tr></table></figure>
<h5 id="5-深度冻结"><a href="#5-深度冻结" class="headerlink" title="[5] 深度冻结"></a>[5] 深度冻结</h5><p>你可以“深度冻结”一个对象，具体方法为，首先在这个对象上调用 Object.freeze(..)， 然后遍历它引用的所有对象并在这些对象上调用 Object.freeze(..)。但是一定要小心，因 为这样做有可能会在无意中冻结其他(共享)对象。</p>
<h4 id="8-GET"><a href="#8-GET" class="headerlink" title="(8) [[GET]]"></a>(8) [[GET]]</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; </span><br><span class="line">	a: <span class="number">2</span>&#125;;myObject.a; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h5 id="1-GET操作"><a href="#1-GET操作" class="headerlink" title="[1] GET操作"></a>[1] GET操作</h5><p>myObject.a 是一次属性访问，但是这条语句并不仅仅是在 myObjet 中查找名字为 a 的属性， 虽然看起来好像是这样。</p>
<p>myObject.a 在 myObject 上实际上是实现了 [[Get]] 操作(有点像函数调 用[[Get]]()</p>
<ol>
<li>对象默认的内置 [[Get]] 操作首先在对象中查找是否有名称相同的属性， 如果找到就会返回这个属性的值</li>
<li>[[Get]] 算法的定义会执行遍历可能存在的 [[Prototype]] 链 (第五章详细解释)</li>
</ol>
<h5 id="2-返回值"><a href="#2-返回值" class="headerlink" title="[2] 返回值"></a>[2] 返回值</h5><ul>
<li>无论如何都没有找到名称相同的属性，那 [[Get]] 操作会返回值 undefined</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; </span><br><span class="line">	a:<span class="number">2</span>&#125;;myObject.b; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意，这种方法和访问变量时是不一样的</li>
</ul>
<p>词法作用域中不存在的变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// Uncaught ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>
<p>对象查找不到属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; </span><br><span class="line">	a:<span class="number">2</span>&#125;;myObject.b; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<ul>
<li>[[Get]] 操作对 myObject.b 进行了更复杂的处理</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; </span><br><span class="line">	a: <span class="literal">undefined</span>&#125;;myObject.a; <span class="comment">// undefined</span>myObject.b; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>由于仅根据返回值无法判断出到底变量的值为 undefined 还是变量不存在，所以 [[Get]] 操作返回了 undefined。</p>
<h4 id="9-PUT"><a href="#9-PUT" class="headerlink" title="(9) [[PUT]]"></a>(9) [[PUT]]</h4><p>[[Put]] 被触发时，实际的行为取决于许多因素，包括对象中是否已经存在这个属性</p>
<p>如果已经存在这个属性，[[Put]] 算法大致会检查下面这些内容。</p>
<ol>
<li>属性是否是访问描述符(参见3.3.9节)如果是并且存在setter就调用setter。</li>
<li>属性的数据描述符中writable是否是false?如果是，在非严格模式下静默失败，在<br>严格模式下抛出 TypeError 异常。</li>
<li>如果都不是，将该值设置为属性的值。</li>
</ol>
<p>如果对象中不存在这个属性，[[Put]] 操作会更加复杂。我们会在第 5 章讨论 [[Prototype]] 时详细进行介绍。</p>
<h4 id="10-Getter和Setter"><a href="#10-Getter和Setter" class="headerlink" title="(10) Getter和Setter"></a>(10) Getter和Setter</h4><h5 id="1-Getter"><a href="#1-Getter" class="headerlink" title="[1] Getter"></a>[1] Getter</h5><p>当你给一个属性定义 getter、setter 或者两者都有时，这个属性会被定义为“访问描述 符”(和“数据描述符”相对)</p>
<p>对象默认的 [[Put]] 和 [[Get]] 操作分别可以控制属性值的设置和获取。</p>
<ul>
<li>在 ES5 中可以使用 getter 和 setter 部分改写默认操作，但是只能应用在单个属性上，无法 应用在整个对象上。</li>
<li>getter 是一个隐藏函数，会在获取属性值时调用。setter 也是一个隐藏 函数，会在设置属性值时调用。</li>
<li>对于访问描述符来说，会<strong>忽略它们的 value 和 writable 特性</strong>，关心 set 和 get(还有 configurable 和 enumerable)特性。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 形式1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  get a() &#123;</span><br><span class="line">   	<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 形式2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty( obj, <span class="string">'b'</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">3</span> &#125;,</span><br><span class="line">  	enumerable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"> );</span><br><span class="line"></span><br><span class="line">obj.a = <span class="string">'666'</span>; <span class="comment">//readonly</span></span><br><span class="line">obj.b = <span class="string">'666'</span>; <span class="comment">//readonly</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.a); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.b); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<p>不管是对象文字语法中的get a() { .. }，还是defineProperty(..)中的显式定义，二者 都会在对象中创建一个不包含值的属性，对于这个属性的访问会自动调用一个隐藏函数， 它的返回值会被当作属性访问的返回值:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;<span class="comment">// 给 a 定义一个 </span></span><br><span class="line">	getter get a() &#123;		<span class="keyword">return</span> <span class="number">2</span>; </span><br><span class="line">	&#125;;myObject.a = <span class="number">3</span>;myObject.a; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>由于我们只定义了 a 的 getter，所以对 a 的值进行设置时 set 操作会忽略赋值操作，不会抛 出错误。而且即便有合法的 setter，由于我们自定义的 getter 只会返回 2，所以 set 操作是 没有意义的。</p>
<h5 id="2-Setter"><a href="#2-Setter" class="headerlink" title="[2] Setter"></a>[2] Setter</h5><p>setter 会覆盖单个属性默认的 [[Put]](也被称为赋值)操作。<strong>通常来说 getter 和 setter 是成对出现的</strong>(只定义一个的话 通常会产生意料之外的行为):</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> obj = &#123;</span><br><span class="line">   get a() &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>._a</span><br><span class="line">   &#125;,</span><br><span class="line">   set a(val) &#123;</span><br><span class="line">      	<span class="keyword">this</span>._a = val * <span class="number">100</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.a);  <span class="comment">// 200</span></span><br></pre></td></tr></table></figure>
<p>在本例中，实际上我们把赋值([[Put]])操作中的值 2 存储到了另一个变量 _a_ 中。名称 _a_ 只是一种惯例，没有任何特殊的行为——和其他普通属性一样。</p>
<h4 id="11-存在性"><a href="#11-存在性" class="headerlink" title="(11) 存在性"></a>(11) 存在性</h4><p>如 myObject.a 的属性访问返回值可能是 undefined，但是这个值有可能 是属性中存储的 undefined，也可能是因为属性不存在所以返回 undefined。那么如何区分 这两种情况呢?</p>
<ul>
<li>不访问属性值的情况下判断对象中是否存在这个属性:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"a"</span> <span class="keyword">in</span> myObject); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"b"</span> <span class="keyword">in</span> myObject); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(myObject.hasOwnProperty( <span class="string">"a"</span> )); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(myObject.hasOwnProperty( <span class="string">"b"</span> )); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<ul>
<li>in操作符：检查属性是否在对象及其 [[Prototype]] 原型链中</li>
<li><p>hasOwnProperty： 只会检查属性是否在 myObject 对象中，不会检查 [[Prototype]] 链</p>
</li>
<li><p>所有的普通对象都可以通过对于 Object.prototype 的委托(参见第 5 章)来访问 hasOwnProperty(..)，但是有的对象可能没有连接到 Object.prototype(通过 Object. create(null) 来创建——参见第 5 章)。在这种情况下，形如 myObejct.hasOwnProperty(..) 就会失败。</p>
</li>
<li><p>这时可以使用一种更加强硬的方法来进行判断:Object.prototype.hasOwnProperty. call(myObject,”a”)，它借用基础的 hasOwnProperty(..) 方法并把它显式绑定(参见第 2 章)到 myObject 上。</p>
</li>
<li><p>看起来 in 操作符可以检查容器内是否有某个值，但是它实际上检查的是某 个属性名是否存在。对于数组来说这个区别非常重要，4 in [2, 4, 6]的结 果并不是你期待的 True，因为 [2, 4, 6] 这个数组中包含的属性名是 0、1、 2，没有 4。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]); <span class="comment">//Array 属性名 0 1 2 3 因此false</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="1-枚举"><a href="#1-枚举" class="headerlink" title="[1] 枚举"></a>[1] 枚举</h5><ul>
<li>什么是“可枚举性”：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123; &#125;;</span><br><span class="line">Object.defineProperty(myObject, &quot;a&quot;);</span><br><span class="line">Object.defineProperty(myObject, &quot;b&quot;, &#123; enumerable: false, value: 3 &#125;);</span><br><span class="line"></span><br><span class="line">console.log(myObject.b); // 3</span><br><span class="line"></span><br><span class="line">console.log((&quot;b&quot; in myObject)); // true</span><br><span class="line"></span><br><span class="line">myObject.hasOwnProperty( &quot;b&quot; ); // true</span><br><span class="line"></span><br><span class="line">for (var k in myObject) &#123;</span><br><span class="line">  console.log( k, myObject[k] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>myObject.b 确实存在并且有访问值，但是却不会出现在 for..in 循环中(尽管 可以通过 in 操作符来判断是否存在),<strong>原因是“可枚举”就相当于“可以出现在对象属性 的遍历中”。</strong></p>
<ul>
<li><p>在数组上应用 for..in 循环有时会产生出人意料的结果，因为这种枚举不 仅会包含所有数值索引，还会包含所有可枚举属性。最好只在对象上应用 for..in 循环，如果要遍历数组就使用传统的 for 循环来遍历数值索引。</p>
</li>
<li><p>其他方法区分属性是否可枚举：</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; &#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myObject, <span class="string">"a"</span>, &#123; <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="number">2</span> &#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myObject,<span class="string">"b"</span>,&#123; <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="number">3</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myObject.propertyIsEnumerable( <span class="string">"a"</span> )); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(myObject.propertyIsEnumerable( <span class="string">"b"</span> )); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys( myObject )); <span class="comment">// ["a"]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames( myObject )); <span class="comment">// ["a", "b"]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>propertyIsEnumerable(..) 会检查给定的属性名<strong>是否直接存在于对象中(而不是在原型链上)</strong>并且满足 enumerable:true。</li>
<li>Object.keys(..) 会返回一个数组，包含所有可枚举属性，Object.getOwnPropertyNames(..) 会返回一个数组，包含所有属性，无论它们是否可枚举。</li>
<li>in 和 hasOwnProperty(..) 的区别在于是否查找 [[Prototype]] 链，然而，Object.keys(..) 和 Object.getOwnPropertyNames(..) 都只会查找对象直接包含的属性。</li>
<li>(目前)并没有内置的方法可以获取 in 操作符使用的属性列表(对象本身的属性以 及 [[Prototype]] 链中的所有属性，参见第 5 章)。不过你可以递归遍历某个对象的整条 [[Prototype]] 链并保存每一层中使用 Object.keys(..) 得到的属性列表——只包含可枚举属性。</li>
</ul>
<h3 id="3-遍历"><a href="#3-遍历" class="headerlink" title="3.遍历"></a>3.遍历</h3><p>for..in 循环可以用来遍历对象的可枚举属性列表(包括 [[Prototype]] 链)。但是如何遍<br>历属性的值呢?</p>
<ul>
<li>对于数值索引的数组来说，可以使用标准的 for 循环来遍历值:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; myArray.length; i++) &#123; </span><br><span class="line">	<span class="built_in">console</span>.log( myArray[i] ); <span class="comment">// 1 2 3</span>&#125;</span><br></pre></td></tr></table></figure>
<p>这实际上并不是在遍历值，而是遍历下标来指向值，如 myArray[i]。</p>
<h5 id="1-迭代方法："><a href="#1-迭代方法：" class="headerlink" title="[1] 迭代方法："></a>[1] 迭代方法：</h5><p>ES5 中增加了一些数组的辅助迭代器，包括 forEach(..)、every(..) 和 some(..)。每种辅 助迭代器都可以接受一个回调函数并把它应用到数组的每个元素上，唯一的区别就是它们 对于回调函数返回值的处理方式不同。</p>
<p>every(..) 和 some(..) 中特殊的返回值和普通 for 循环中的 break 语句类似，它们会提前 终止遍历。</p>
<ul>
<li><p>forEach</p>
<p>  forEach(..) 会遍历数组中的所有值并忽略回调函数的返回值。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">a.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value,index, arr</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);  <span class="comment">// 1 2 3</span></span><br><span class="line">    <span class="built_in">console</span>.log(index); <span class="comment">// 0 1 2</span></span><br><span class="line">    <span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>every</p>
<ul>
<li><p>every(..) 会一直运行直到回调函数返回 false(或者“假”值)</p>
</li>
<li><p>如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。</p>
</li>
<li><p>如果所有元素都满足条件，则返回 true。</p>
<p>  <strong>注意：</strong> every() 不会对空数组进行检测。</p>
<p>  <strong>注意：</strong> every() 不会改变原始数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.every(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue,index,arr</span>), <span class="title">thisValue</span>);</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<pre><code>例子：

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> res = a.every(<span class="function"><span class="keyword">function</span>(<span class="params">value,index, arr</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> value &gt; <span class="number">0</span>;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log(res); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li><p>some</p>
<p>  some(..) 会一直运行直到回调函数返回 true(或者 “真”值)。</p>
<ul>
<li>如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。</li>
<li><p>如果没有满足条件的元素，则返回false。</p>
<p>  注意： some() 不会对空数组进行检测。</p>
<p>  注意： some() 不会改变原始数组。</p>
</li>
</ul>
</li>
</ul>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.some(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue,index,arr</span>),<span class="title">thisValue</span>)</span></span><br></pre></td></tr></table></figure>

例子：

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> res = a.some(<span class="function"><span class="keyword">function</span>(<span class="params">value,index, arr</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> value &lt; <span class="number">1</span>;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log(res); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li><p>for in</p>
<p>  使用 for..in 遍历对象是无法直接获取属性值的，因为它实际上遍历的是对象中的所有可枚举属性，你需要手动获取属性值。</p>
</li>
<li><p><strong>for of</strong></p>
<p>  那么如何直接遍历值而不是数组下标(或者对象属性)呢?幸好，ES6 增加了一种用来遍 历数组的 for..of 循环语法(如果对象本身定义了迭代器的话也可以遍历对象):</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArray = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ];<span class="keyword">for</span> (<span class="keyword">var</span> v <span class="keyword">of</span> myArray) &#123; </span><br><span class="line">	<span class="built_in">console</span>.log( v ); <span class="comment">// 1 // 2 // 3</span>&#125;</span><br><span class="line"><span class="string">``</span><span class="string">`- for..of 循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的 next() 方法来遍历所有返回值。</span></span><br><span class="line"><span class="string">- 数组有内置的 @@iterator，因此 for..of 可以直接应用在数组上。我们使用内置的 @@ iterator 来手动遍历数组，看看它是怎么工作的:	</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="keyword">var</span> myArray = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ];<span class="keyword">var</span> it = myArray[<span class="built_in">Symbol</span>.iterator]();it.next(); <span class="comment">// &#123; value:1, done:false &#125; </span></span><br><span class="line">it.next(); <span class="comment">// &#123; value:2, done:false &#125; </span></span><br><span class="line">it.next(); <span class="comment">// &#123; value:3, done:false &#125; </span></span><br><span class="line">it.next(); <span class="comment">// &#123; done:true &#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>调用迭代器的 next() 方法会返回形式为 { value: .. , done: .. } 的值， value 是当前的遍历值，done 是一个布尔值，表示是否还有可以遍历的值。</li>
<li>和值“3”一起返回的是 done:false，乍一看好像很奇怪，你必须再调用一次 next() 才能得到 done:true，从而确定完成遍历。这个机制和 ES6 中发生器函数的语义相 关，不过已经超出了我们的讨论范围。</li>
<li>和数组不同，普通的对象没有内置的 @@iterator，所以无法自动完成 for..of 遍历。之所 以要这样做，有许多非常复杂的原因，不过简单来说，这样做是为了避免影响未来的对象 类型。</li>
</ul>
<p>当然，你可以给任何想遍历的对象定义 @@iterator，举例来说:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    b: <span class="number">3</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">Object</span>.defineProperty( myObject, <span class="built_in">Symbol</span>.iterator, &#123; </span><br><span class="line"> 	enumerable: <span class="literal">false</span>,</span><br><span class="line">   writable: <span class="literal">false</span>,</span><br><span class="line">   configurable: <span class="literal">true</span>,</span><br><span class="line">   value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">   		<span class="keyword">var</span> o = <span class="keyword">this</span>;</span><br><span class="line">       <span class="keyword">var</span> idx = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">var</span> ks = <span class="built_in">Object</span>.keys( o ); </span><br><span class="line">       <span class="keyword">return</span> &#123;</span><br><span class="line">          next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> &#123;</span><br><span class="line">           value: o[ks[idx++]],</span><br><span class="line">           done: (idx &gt; ks.length)</span><br><span class="line">        &#125;;</span><br><span class="line">      	&#125; </span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动遍历 myObject</span></span><br><span class="line"><span class="keyword">var</span> it = myObject[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">it.next(); <span class="comment">// &#123; value:2, done:false &#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123; value:3, done:false &#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123; value:undefined, done:true &#125;</span></span><br><span class="line"><span class="comment">// 用 for..of 遍历 myObject</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> v <span class="keyword">of</span> myObject) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log( v );     <span class="comment">// 2 // 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>for..of 循环每次调用 myObject 迭代器对象的 next() 方法时，内部的指针都会向前移动并 返回对象属性列表的下一个值(再次提醒，需要注意遍历对象属性 / 值时的顺序)。</li>
</ul>
<ul>
<li>代码中的遍历非常简单，只是传递了属性本身的值。不过只要你愿意，当然也可以在自定 义的数据结构上实现各种复杂的遍历。</li>
</ul>
<p>无限”迭代器例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> randoms = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="built_in">Math</span>.random() &#125;; &#125;</span><br><span class="line">    &#125;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> randoms_pool = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> n <span class="keyword">of</span> randoms) &#123;</span><br><span class="line">  randoms_pool.push( n );</span><br><span class="line">  <span class="comment">// 防止无限运行!</span></span><br><span class="line">  <span class="keyword">if</span> (randoms_pool.length === <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(randoms_pool);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个迭代器会生成“无限个”随机数，因此我们添加了一条 break 语句，防止程序被挂起。</p>
<p><strong>ps. 补充知识（关于Symbol.iterator）</strong></p>
<p>我们使用 ES6 中的符号 Symbol.iterator 来获取对象的 @@iterator 内部属 性。之前我们简单介绍过符号(Symbol，参见 3.3.1 节)，跟这里的原理是相 同的。引用类似 iterator 的特殊属性时要使用符号名，而不是符号包含的 值。此外，虽然看起来很像一个对象，但是 @@iterator 本身并不是一个迭代 器对象，而是一个返回迭代器对象的函数——这点非常精妙并且非常重要。</p>
<p>遍历数组下标时采用的是数字顺序(for 循环或者其他迭代器)，但是遍历对 象属性时的顺序是不确定的，在不同的 JavaScript 引擎中可能不一样。因此， 在不同的环境中需要保证一致性时，一定不要相信任何观察到的顺序，它们 是不可靠的。</p>
<h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h3><h4 id="1-定义对象的方式"><a href="#1-定义对象的方式" class="headerlink" title="(1)定义对象的方式"></a>(1)定义对象的方式</h4><ul>
<li>字面量 （更常用）</li>
<li>构造函数 （提供更多选项）</li>
</ul>
<h4 id="2-对象的类型"><a href="#2-对象的类型" class="headerlink" title="(2)对象的类型"></a>(2)对象的类型</h4><ul>
<li>对象是引用数据类型</li>
<li>对象有包括 function 在内的子类型，不同子类型具有不同 的行为，比如内部标签[object Array]表示这是对象的子类型数组。</li>
</ul>
<h4 id="3-对象的属性"><a href="#3-对象的属性" class="headerlink" title="(3)对象的属性"></a>(3)对象的属性</h4><ul>
<li>对象就是键 / 值对的集合</li>
<li>propName 或者 [“propName”] 语法来获取属性值</li>
<li><p>访问属性时，引擎实际上会调用内部的默认 [[Get]] 操作(在设置属性值时是 [[Put]])， [[Get]] 操作会检查对象本身是否包含这个属性，如果没找到的话还会查找 [[Prototype]] 链(参见第 5 章)。</p>
</li>
<li><p>属性的特性可以通过属性描述符来控制，比如 writable 和 configurable。</p>
</li>
<li>可以使用 Object.preventExtensions(..)、Object.seal(..) 和 Object.freeze(..) 来设置对象(及其 属性)的不可变性级别。</li>
<li>属性不一定包含值——它们可能是具备 getter/setter 的“访问描述符”。</li>
<li>属性可以是 可枚举或者不可枚举的，这决定了它们是否会出现在 for..in 循环中。</li>
</ul>
<h4 id="4-对象的遍历"><a href="#4-对象的遍历" class="headerlink" title="(4)对象的遍历"></a>(4)对象的遍历</h4><ul>
<li>ES6 的 for..of 语法来遍历数据结构(数组、对象，等等)中的值，for..of 会寻找内置或者自定义的 @@iterator 对象并调用它的 next() 方法来遍历数据值。</li>
</ul>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://www.neohuang.com/child/2018/09/29/not-know-js-review-object/" data-id="cjmn38nq1000yujm7aj5l6eg6" class="article-share-link"><i class="fa fa-share"></i>Compartir</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            <!--
    
        <a href="http://www.neohuang.com/child/2018/09/29/not-know-js-review-object/#comments" class="article-comment-link">Comentarios</a>
    
-->
        </footer>
    </div>
    
</article>



    <article id="post-not-know-js-review-this" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2018/09/25/not-know-js-review-this/">你不知道的js复习笔记 (this)</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2018/09/25/not-know-js-review-this/">
            <time datetime="2018-09-24T16:00:00.000Z" itemprop="datePublished">2018-09-25</time>
        </a>
    </div>


                        
                        
                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h2 id="第二部分-关于this"><a href="#第二部分-关于this" class="headerlink" title="第二部分 关于this"></a>第二部分 关于this</h2><p>参考： 《你不知道的javascript—上卷》 第二部分    </p>
<h3 id="1-为什么要使用this"><a href="#1-为什么要使用this" class="headerlink" title="1. 为什么要使用this"></a>1. 为什么要使用this</h3><p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identify</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name.toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">speak</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> greeting = <span class="string">"Hello, I'm "</span> + identify.call( <span class="keyword">this</span> );</span><br><span class="line">  <span class="built_in">console</span>.log( greeting );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> me = &#123;</span><br><span class="line">  name: <span class="string">"Kyle"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> you = &#123;</span><br><span class="line">  name: <span class="string">"Reader"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">identify.call( me ); <span class="comment">// KYLE</span></span><br><span class="line">identify.call( you ); <span class="comment">// READER</span></span><br><span class="line">speak.call( me ); <span class="comment">// Hello, 我是 KYLE speak.call( you ); // Hello, 我是 READER</span></span><br></pre></td></tr></table></figure>
<p>这段代码可以在不同的上下文对象(me 和 you)中重复使用函数 identify() 和 speak()， 不用针对每个对象编写不同版本的函数。</p>
<p>如果不使用 this，那就需要给 identify() 和 speak() 显式传入一个上下文对象。</p>
<p>转换成代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identify</span>(<span class="params">context</span>) </span>&#123;	<span class="keyword">return</span> context.name.toUpperCase();&#125;<span class="function"><span class="keyword">function</span> <span class="title">speak</span>(<span class="params">context</span>) </span>&#123;	<span class="keyword">var</span> greeting = <span class="string">"Hello, I'm "</span> + identify( context ); 	<span class="built_in">console</span>.log( greeting );&#125;identify( you ); <span class="comment">// READER</span>speak( me ); <span class="comment">//hello, 我是 KYLE</span></span><br></pre></td></tr></table></figure>
<p>然而，this 提供了一种更优雅的方式来隐式“传递”一个对象引用，因此可以将 API 设计<br>得更加简洁并且易于复用。</p>
<p>随着你的使用模式越来越复杂，显式传递上下文对象会让代码变得越来越混乱，使用 this 则不会这样。</p>
<h4 id="（1）误解"><a href="#（1）误解" class="headerlink" title="（1）误解"></a>（1）误解</h4><p>有两种常见的对于 this 的解释，但是它 们都是错误的。</p>
<h5 id="1-指向自身"><a href="#1-指向自身" class="headerlink" title="[1] 指向自身"></a>[1] 指向自身</h5><p>人们很容易把 this 理解成指向函数自身，但是实际并不是</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span> + num);</span><br><span class="line">  <span class="keyword">this</span>.count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">      foo(i); <span class="comment">// foo 6 7 8 9</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.count); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.conut) <span class="comment">//NAN</span></span><br></pre></td></tr></table></figure>
<ul>
<li>执行foo.count = 0时，的确向函数对象foo添加了一个属性count。但是函数内部代码 this.count 中的 this 并不是指向那个函数对象，所以虽然属性名相同</li>
<li>实际上，如果他深入探索的话，就会发现这段代码在 无意中创建了一个全局变量 count(原理参见第 2 章)，它的值为 NaN。</li>
</ul>
<p><strong>如果要从函数对象内部引用它自身，那只使用 this 是不够的</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;	foo.count = <span class="number">4</span>; <span class="comment">// foo指向它自身</span></span><br><span class="line">	<span class="comment">// foo();</span>&#125;setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;	<span class="comment">// 匿名(没有名字的)函数无法指向自身</span></span><br><span class="line">	<span class="comment">// 虽然可以使用arguments. callee，但不建议</span>&#125;, <span class="number">10</span> );</span><br><span class="line"></span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;	<span class="comment">// 匿名(没有名字的)函数无法指向自身</span></span><br><span class="line">	<span class="comment">// 虽然可以使用arguments. callee，但不建议</span></span><br><span class="line">	foo(); <span class="comment">//可以使用具名函数</span>&#125;, <span class="number">10</span> );</span><br></pre></td></tr></table></figure>
<p><strong>使用this解决问题</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span> + num);</span><br><span class="line">  <span class="keyword">this</span>.count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">        foo.call(foo,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.count); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.count); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h5 id="2-它的作用域"><a href="#2-它的作用域" class="headerlink" title="[2] 它的作用域"></a>[2] 它的作用域</h5><p>第二种常见的误解是，this 指向函数的作用域。需要明确的是，</p>
<p><strong>this 在任何情况下都不指向函数的词法作用域。</strong></p>
<ul>
<li>在 JavaScript 内部，作用 域确实和对象类似，可见的标识符都是它的属性。但是作用域“对象”无法通过 JavaScript 代码访问，它存在于 JavaScript 引擎内部。</li>
</ul>
<p>思考一下下面的代码，它试图(但是没有成功)跨越边界，使用 this 来隐式引用函数的词 法作用域:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">2</span>;	<span class="keyword">this</span>.bar(); </span><br><span class="line">&#125;<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">	<span class="built_in">console</span>.log( <span class="keyword">this</span>.a );&#125;foo(); <span class="comment">// ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>
<ul>
<li>调用 bar() 最自然的方法是省略前面的 this，直接使用词法引用标识符。</li>
<li>编写这段代码的开发者还试图使用 this 联通 foo() 和 bar() 的词法作用域，从而让 bar() 可以访问 foo() 作用域里的变量 a。这是不可能实现的，你不能使用 this 来引用一 个词法作用域内部的东西。</li>
</ul>
<h5 id="3-this-到底是什么"><a href="#3-this-到底是什么" class="headerlink" title="[3] this    到底是什么"></a>[3] this    到底是什么</h5><ul>
<li>this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调 用时的各种条件。<strong>this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式</strong>。</li>
<li>当一个函数被调用时，会创建一个活动记录(有时候也称为执行上下文)。这个记录会包 含函数在哪里被调用(调用栈)、函数的调用方法、传入的参数等信息。this 就是记录的 其中一个属性，会在函数执行的过程中用到。</li>
</ul>
<p>this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。</p>
<h3 id="1-this全面解析"><a href="#1-this全面解析" class="headerlink" title="1. this全面解析"></a>1. this全面解析</h3><h4 id="1-调用位置分析"><a href="#1-调用位置分析" class="headerlink" title="(1)调用位置分析"></a>(1)调用位置分析</h4><p>在理解 this 的绑定过程之前，首先要理解调用位置:调用位置就是函数在代码中被调用的 位置(而不是声明的位置)。</p>
<p>通常来说，寻找调用位置就是寻找“函数被调用的位置”，但是做起来并没有这么简单， 因为某些编程模式可能会隐藏真正的调用位置。</p>
<p><strong>寻找调用位置就是寻找“函数被调用的位置”，最重要的是要分析调用栈(就是为了到达当前执行位置所调用的所有函数)。我们关心的 调用位置就在当前正在执行的函数的前一个调用中。</strong></p>
<h4 id="2-绑定规则"><a href="#2-绑定规则" class="headerlink" title="(2)绑定规则"></a>(2)绑定规则</h4><p>我们来看看在函数的执行过程中调用位置如何决定 this 的绑定对象。</p>
<p>你必须找到调用位置，然后判断需要应用下面<strong>四条规则</strong>中的哪一条。</p>
<h5 id="1-默认绑定"><a href="#1-默认绑定" class="headerlink" title="[1] 默认绑定"></a>[1] 默认绑定</h5><p><strong>独立函数调用下的绑定</strong>。可以把这条规则看作是无法应用<br>其他规则时的默认规则。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo() <span class="comment">// window</span></span><br></pre></td></tr></table></figure>
<p>更清晰：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'baz'</span>);</span><br><span class="line">  foo();</span><br><span class="line">&#125;</span><br><span class="line">baz(); <span class="comment">// window</span></span><br></pre></td></tr></table></figure>
<p>foo() 是直接使用不带任何修饰的函数引用进行调用的，因此只能使用 默认绑定，无法应用其他规则。函数调用时应用了 this 的默认绑定，因此 this 指向全局对象。</p>
<p>再看下例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"><span class="meta">	"use strict"</span>;   <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );&#125;<span class="keyword">var</span> a = <span class="number">2</span>;foo(); <span class="comment">// TypeError: this is undefined</span></span><br></pre></td></tr></table></figure>
<p><strong>严格模式下，全局对象将无法使用默认绑定，因此 this 会绑定 到 undefined</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );&#125;<span class="keyword">var</span> a = <span class="number">2</span>;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="meta">	"use strict"</span>;	foo(); <span class="comment">// 2</span>&#125;)();</span><br><span class="line"><span class="string">``</span><span class="string">`##### [2] 隐式绑定</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含 **（比较容易混淆）**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">	<span class="built_in">console</span>.log( <span class="keyword">this</span>.a );&#125;<span class="keyword">var</span> obj = &#123; </span><br><span class="line">	a: <span class="number">2</span>,	<span class="attr">foo</span>: foo </span><br><span class="line">&#125;;obj.foo(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>无论是直接在 obj 中定义还是先定义再添加为引用属性,foo()这个函数严格来说都不属于 obj 对象。</p>
<ul>
<li>调用位置会使用 obj 上下文来引用函数,因此你可以说函数被调用时 obj 对象“拥 有”或者“包含”它。</li>
<li><p>当函数引 用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。因为调 用 foo() 时 this 被绑定到 obj，因此 this.a 和 obj.a 是一样的。</p>
</li>
<li><p>对象属性引用链中只有最顶层或者说最后一层会影响调用位置</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">	<span class="built_in">console</span>.log( <span class="keyword">this</span>.a );&#125;<span class="keyword">var</span> obj2 = &#123; </span><br><span class="line">	a: <span class="number">42</span>,	<span class="attr">foo</span>: foo </span><br><span class="line">&#125;;<span class="keyword">var</span> obj1 = &#123; </span><br><span class="line">	a: <span class="number">2</span>,	<span class="attr">obj2</span>: obj2</span><br><span class="line">	&#125;;   obj1.obj2.foo(); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>隐式丢失</p>
<p>  一个最常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把 this 绑定到全局对象或者 undefined 上，取决于是否是严格模式。</p>
<p>  （1） 引用传递</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; </span><br><span class="line">	a: <span class="number">2</span>,	<span class="attr">foo</span>: foo </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = obj.foo; <span class="comment">// 函数别名!</span><span class="keyword">var</span> a = <span class="string">"oops, global"</span>; <span class="comment">// a是全局对象的属性 </span></span><br><span class="line">bar(); <span class="comment">// "oops, global"</span></span><br></pre></td></tr></table></figure>
<p>  虽然 bar 是 obj.foo 的一个引用，<strong>但是实际上，它引用的是 foo 函数本身</strong>，因此此时的 bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。</p>
<p>  （2） 回调传递</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// 传入回调</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">doFoo</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">		fn(); <span class="comment">// 调用位置</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">var</span> obj = &#123; </span><br><span class="line">		a: <span class="number">2</span>,		<span class="attr">foo</span>: foo </span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="string">"oops, global"</span>; <span class="comment">// a是全局对象的属性 </span></span><br><span class="line">	doFoo( obj.foo ); <span class="comment">// "oops, global"</span></span><br><span class="line">	<span class="string">``</span><span class="string">`	</span></span><br><span class="line"><span class="string">参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值，因此也是默认绑定。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	(3) 传入语言内置函数</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	`</span><span class="string">``</span>javascript</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">		<span class="built_in">console</span>.log( <span class="keyword">this</span>.a )</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">var</span> obj = &#123; </span><br><span class="line">		a: <span class="number">2</span>,		<span class="attr">foo</span>: foo </span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">var</span> a = <span class="string">"oops, global"</span>; <span class="comment">// a是全局对象的属性</span></span><br><span class="line">	</span><br><span class="line">	setTimeout( obj.foo, <span class="number">100</span> ); <span class="comment">// "oops, global"</span></span><br></pre></td></tr></table></figure>
<p>  JavaScript 环境中内置的 setTimeout() 函数实现和下面的伪代码类似:</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setTimeout</span>(<span class="params">fn,delay</span>) </span>&#123; </span><br><span class="line">	<span class="comment">// 等待 delay 毫秒</span>	fn(); <span class="comment">// &lt;-- 调用位置!</span>&#125;</span><br></pre></td></tr></table></figure>
<p>  除此之外，还有一种情 况 this 的行为会出乎我们意料:调用回调函数的函数可能会修改 this。在一些流行的 JavaScript 库中事件处理器常会把回调函数的 this 强制绑定到触发事件的 DOM 元素上。    </p>
</li>
</ul>
<h5 id="3-显式绑定"><a href="#3-显式绑定" class="headerlink" title="[3] 显式绑定"></a>[3] 显式绑定</h5><p>我们必须在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把 this 间接(隐式)绑定到这个对象上。</p>
<p>对象内部包含函数引用，而想在某个对象上强制,可以使用函数的 call(..) 和 apply(..) 方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> obj = &#123;</span><br><span class="line">   a: <span class="string">'local'</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> a = <span class="string">'global'</span>;</span><br><span class="line"></span><br><span class="line">foo.call(obj);</span><br></pre></td></tr></table></figure>
<p>如果你传入了一个原始值(字符串类型、布尔类型或者数字类型)来当作 this 的绑定对 象，这个原始值会被转换成它的对象形式(也就是new String(..)、new Boolean(..)或者 new Number(..))。这通常被称为“装箱”。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.call(<span class="string">'111'</span>); <span class="comment">// String &#123;"111"&#125; // 包装对象</span></span><br></pre></td></tr></table></figure>
<p>可惜，显式绑定仍然无法解决我们之前提出的丢失绑定问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="string">'local'</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> a = <span class="string">'global'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> bar = foo.call(obj); <span class="comment">// 已经执行</span></span><br><span class="line">  bar(); <span class="comment">// Uncaught TypeError</span></span><br></pre></td></tr></table></figure>
<p><strong>1.硬绑定：</strong></p>
<p>但是显式绑定的一个变种可以解决这个问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  foo.call( obj );</span><br><span class="line">&#125;;</span><br><span class="line">bar(); <span class="comment">// 2</span></span><br><span class="line">setTimeout(bar,<span class="number">1000</span>); <span class="comment">//2</span></span><br><span class="line">bar.call(<span class="built_in">window</span>); <span class="comment">// 2  硬绑定的 bar 不可能再修改它的 this</span></span><br></pre></td></tr></table></figure>
<p>因此强制把 foo 的 this 绑定到了 obj。无论之后如何调用函数 bar，它 总会手动在 obj 上调用 foo。这种绑定是一种显式的强制绑定，因此我们称之为硬绑定。</p>
<p><strong>包裹函数，传入所有的参数并返回接收到的所有值:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.a, something); <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a + something;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> foo.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = bar(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p><strong>创建一个 i 可以重复使用的辅助函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a, something);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + something;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">fn,obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> bar = bind(foo,obj);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> b = bar(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br></pre></td></tr></table></figure>
<p>因此ES5 中提供了内置的方法 Function.prototype. bind</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123; </span><br><span class="line">	<span class="built_in">console</span>.log( <span class="keyword">this</span>.a, something ); </span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.a + something;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123; </span><br><span class="line">	a:<span class="number">2</span>&#125;;<span class="keyword">var</span> bar = foo.bind( obj );<span class="keyword">var</span> b = bar( <span class="number">3</span> ); <span class="comment">// 2 3 console.log( b ); // 5</span></span><br></pre></td></tr></table></figure>
<p>bind(..) 会返回一个硬编码的新函数，它会把参数设置为 this 的上下文并调用原始函数。</p>
<p><strong>2.API调用的“上下文”</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( el, <span class="keyword">this</span>.id );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">id: <span class="string">"awesome"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用 foo(..) 时把 this 绑定到 obj</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach( foo, obj );</span><br><span class="line"><span class="comment">// 1 awesome 2 awesome 3 awesome</span></span><br></pre></td></tr></table></figure>
<h5 id="4-new绑定"><a href="#4-new绑定" class="headerlink" title="[4] new绑定"></a>[4] new绑定</h5><p>在传统的面向类的语言中，“构造函数”是类中的一些特殊方法，使用 new 初始化类时会<br>调用类中的构造函数。通常的形式是这样的:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">something = <span class="keyword">new</span> MyClass(..);</span><br></pre></td></tr></table></figure>
<p>然而，JavaScript 中 new 的机制实 际上和面向类的语言完全不同。</p>
<ul>
<li>在 JavaScript 中，构造函数只是一些 使用 new 操作符时被调用的函数。</li>
<li>它们并不会属于某个类，也不会实例化一个类。</li>
<li>实际上， 它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numb = <span class="keyword">new</span> <span class="built_in">Number</span>(..);</span><br><span class="line"><span class="comment">// 当 Number 在 new 表达式中被调用时，它是一个构造函数:它会初始化新创建的 对象。</span></span><br></pre></td></tr></table></figure>
<p>包括内置对象函数(比如 Number(..)，详情请查看第 3 章)在内的所有函数都可 以用 new 来调用，这种函数调用被称为构造函数调用。这里有一个重要但是非常细微的区 别:实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。</p>
<p><strong>new操作符背后</strong></p>
<ol>
<li>创建(或者说构造)一个全新的对象。</li>
<li>这个新对象会被执行[[原型]]连接。</li>
<li>这个新对象会绑定到函数调用的this。</li>
<li>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123; </span><br><span class="line">	<span class="keyword">this</span>.a = a;&#125;<span class="keyword">var</span> bar = <span class="keyword">new</span> foo(<span class="number">2</span>); </span><br><span class="line"><span class="built_in">console</span>.log( bar.a ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>使用 new 来调用 foo(..) 时，我们会构造一个新对象并把它绑定到 foo(..) 调用中的 this 上。new 是最后一种可以影响函数调用时 this 绑定行为的方法，我们称之为 new 绑定。</p>
<h4 id="3-优先级"><a href="#3-优先级" class="headerlink" title="(3)优先级"></a>(3)优先级</h4><h5 id="1-隐式绑定和显式绑定哪个优先级更高"><a href="#1-隐式绑定和显式绑定哪个优先级更高" class="headerlink" title="[1]隐式绑定和显式绑定哪个优先级更高?"></a>[1]隐式绑定和显式绑定哪个优先级更高?</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  a: <span class="number">3</span>,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;;</span><br><span class="line">obj1.foo(); <span class="comment">// 2</span></span><br><span class="line">obj2.foo(); <span class="comment">// 3</span></span><br><span class="line">obj1.foo.call( obj2 ); <span class="comment">// 3</span></span><br><span class="line">obj2.foo.call( obj1 ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p><strong>显式绑定优先级更高</strong></p>
<h5 id="2-new绑定和隐式绑定的优先级谁高谁低"><a href="#2-new绑定和隐式绑定的优先级谁高谁低" class="headerlink" title="[2]new绑定和隐式绑定的优先级谁高谁低"></a>[2]new绑定和隐式绑定的优先级谁高谁低</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj1.foo( <span class="number">2</span> );</span><br><span class="line"><span class="built_in">console</span>.log( obj1.a ); <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> obj1.foo( <span class="number">4</span> );</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( obj1.a ); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bar.a); <span class="comment">// 4 优先级更高</span></span><br></pre></td></tr></table></figure>
<p><strong>new绑定绑定优先级更高</strong></p>
<h5 id="3-new-绑定和显示绑定优先级谁高"><a href="#3-new-绑定和显示绑定优先级谁高" class="headerlink" title="[3] new 绑定和显示绑定优先级谁高"></a>[3] new 绑定和显示绑定优先级谁高</h5><p>在看代码之前先回忆一下硬绑定是如何工作的。Function.prototype.bind(..) 会创建一个 新的包装函数，这个函数会忽略它当前的 this 绑定(无论绑定的对象是什么)，并把我们 提供的对象绑定到 this 上。</p>
<p>这样看起来硬绑定(也是显式绑定的一种)似乎比 new 绑定的优先级更高，无法使用 new 来控制 this 绑定。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = something;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.bind( obj1 );</span><br><span class="line">bar( <span class="number">2</span> );</span><br><span class="line"><span class="built_in">console</span>.log( obj1.a ); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> bar(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log( obj1.a ); <span class="comment">// 2 没有修改obj1.a属性</span></span><br><span class="line"><span class="built_in">console</span>.log( baz.a ); <span class="comment">// 3 将this指向baz，并生成a属性，值为3</span></span><br></pre></td></tr></table></figure>
<p>出乎意料! bar 被硬绑定到 obj1 上，但是 new修改为 3。相反，new 修改了硬绑定(到 obj1 的)调用 bar(..) 中的 this。因为使用了 new 绑定，我们得到了一个名字为 baz 的新对象，并且 baz.a 的值是 3。</p>
<p><strong>实际上，ES5 中内置的 Function.prototype.bind(..) 更加复杂，可以根据这种 bind(..) 是一种 polyfill 代码来分析一下（但实际和ES5 内置的 bind(..) 函数并不完全相同）</strong></p>
<p>简单来说，这段代码会判断硬绑定函数是否是被 new 调用，如果是的话就会使用新创建 的 this 替换硬绑定的 this。</p>
<p><strong>因此某种意义上来说new绑定绑定优先级更高</strong></p>
<p>那么，为什么要在 new 中使用硬绑定函数呢?直接使用普通函数不是更简单吗?</p>
<p>之所以要在 new 中使用硬绑定函数，主要目的是预先设置函数的一些参数，这样在使用 new 进行初始化时就可以只传入其余的参数。<strong>这种技术称为“部 分应用”，是“柯里化”的一种</strong></p>
<p><code>`</code>javascript<br>function foo(p1,p2) {<br>    this.val = p1 + p2;<br>}<br>// 之所以使用 null 是因为在本例中我们并不关心硬绑定的 this 是什么 // 反正使用 new 时 this 会被修改<br>var bar = foo.bind( null, “p1” );<br>var baz = new bar( “p2” );<br>baz.val; // p1p2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">##### [4] 判断this</span><br><span class="line"></span><br><span class="line">1.函数是否在new中调用(new绑定)?如果是的话this绑定的是新创建的对象。</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">var bar = new foo();</span><br></pre></td></tr></table></figure></p>
<p>2.函数是否通过call、apply(显式绑定)或者硬绑定调用?如果是的话，this绑定的是 指定的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = foo.call(obj2);</span><br></pre></td></tr></table></figure>
<p>3.函数是否在某个上下文对象中调用(隐式绑定)?如果是的话，this绑定的是那个上 下文对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = obj1.foo();</span><br></pre></td></tr></table></figure>
<p>4.如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到 全局对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = foo();</span><br></pre></td></tr></table></figure>
<h4 id="4-绑定例外"><a href="#4-绑定例外" class="headerlink" title="(4)绑定例外"></a>(4)绑定例外</h4><p>在某些场景下 this 的绑定行为会出乎意料，你认为应当应用其他绑定规则时，实际上应用 的可能是默认绑定规则。</p>
<h5 id="1-被忽略的this"><a href="#1-被忽略的this" class="headerlink" title="[1] 被忽略的this"></a>[1] 被忽略的this</h5><p>如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值<br>在调用时会被忽略，<strong>实际应用的是默认绑定规则:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">	<span class="built_in">console</span>.log( <span class="keyword">this</span>.a );&#125;<span class="keyword">var</span> a = <span class="number">2</span>;foo.call( <span class="literal">null</span> ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>那么什么情况下你会传入 null 呢?</p>
<p>一种非常常见的做法是使用 apply(..) 来“展开”一个数组，并当作参数传入一个函数。<br>类似地，bind(..) 可以对参数进行柯里化(预先设置一些参数)，这种方法有时非常有用:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log( <span class="string">"a:"</span> + a + <span class="string">", b:"</span> + b );</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> b = foo.bind(<span class="literal">null</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"> b(<span class="number">2</span>);</span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string">这两种方法都需要传入一个参数当作 this 的绑定对象。如果函数并不关心 this 的话，你 仍然需要传入一个占位值，这时 null 可能是一个不错的选择，就像代码所示的那样。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**副作用：**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">总是使用 null 来忽略 this 绑定可能产生一些副作用。如果某个函数确实使用了 this(比如第三方库中的一个函数)，那默认绑定规则会把 this 绑定到全局对象(在浏览 器中这个对象是 window)，这将导致不可预计的后果(比如修改全局对象)。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">##### [2] 更安全的this</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">一种“更安全”的做法是传入一个特殊的对象，把 this 绑定到这个对象不会对你的程序 产生任何副作用。我们可以创建一个“DMZ”(demilitarized zone，非军事区)对象——它就是一个空的非委托的对象(委托在第 5 章和第 6 章介绍)。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在 JavaScript 中创建一个空对象最简单的方法都是 Object.create(null) (详细介绍请看第 5 章)。Object.create(null) 和 &#123;&#125; 很像，但是并不会创建 Object.prototype 这个委托，所以它比 &#123;&#125;“更空”:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(a,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ø = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = foo.bind(ø,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">baz(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h5 id="3-间接引用"><a href="#3-间接引用" class="headerlink" title="[3] 间接引用"></a>[3] 间接引用</h5><p>你有可能(有意或者无意地)创建一个函数的“间接引用”，在这 种情况下，调用这个函数会应用默认绑定规则。</p>
<p><strong>间接引用最容易在赋值时发生:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>: <span class="number">3</span>, <span class="attr">foo</span>: foo&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = &#123;<span class="attr">a</span>:<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">o.foo();</span><br><span class="line"></span><br><span class="line">p.foo = o.foo; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">p.foo(); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">(p.foo = o.foo)(); <span class="comment">// 2	 间接引用</span></span><br></pre></td></tr></table></figure>
<p>赋值表达式 p.foo = o.foo 的返回值是目标函数的引用，因此调用位置是 foo() 而不是 p.foo() 或者 o.foo()。根据我们之前说过的，这里会应用默认绑定。(非严格模式)</p>
<h5 id="4-软绑定"><a href="#4-软绑定" class="headerlink" title="[4] 软绑定"></a>[4] 软绑定</h5><p><strong>硬绑定存在的问题：</strong></p>
<p>硬绑定这种方式可以把 this 强制绑定到指定的对象(除了使用 new 时)，防止函数调用应用默认绑定规则。问题在于，硬绑定会大大降低函数的灵活性，使 用硬绑定之后就无法使用隐式绑定或者显式绑定来修改 this。</p>
<p><strong>改进方法：</strong></p>
<p>如果可以给默认绑定指定一个全局对象和 undefined 以外的值，那就可以实现和硬绑定相 同的效果，同时保留隐式绑定或者显式绑定修改 this 的能力。</p>
<p>可以通过一种被称为软绑定的方法来实现我们想要的效果:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.softBind) &#123; <span class="built_in">Function</span>.prototype.softBind = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fn = <span class="keyword">this</span>;</span><br><span class="line"><span class="comment">// 捕获所有 curried 参数</span></span><br><span class="line">    <span class="keyword">var</span> curried = [].slice.call( <span class="built_in">arguments</span>, <span class="number">1</span> ); </span><br><span class="line">    <span class="keyword">var</span> bound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(</span><br><span class="line">          (!<span class="keyword">this</span> || <span class="keyword">this</span> === (<span class="built_in">window</span> || global)) ?</span><br><span class="line">              obj : <span class="keyword">this</span></span><br><span class="line">      curried.concat.apply( curried, <span class="built_in">arguments</span> )</span><br><span class="line">    ); &#125;;</span><br><span class="line">    bound.prototype = <span class="built_in">Object</span>.create( fn.prototype );</span><br><span class="line">    <span class="keyword">return</span> bound; &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>除了软绑定之外，softBind(..) 的其他原理和 ES5 内置的 bind(..) 类似。它会对指定的函 数进行封装，首先检查调用时的 this，如果 this 绑定到全局对象或者 undefined，那就把 指定的默认对象 obj 绑定到 this，否则不会修改 this。此外，这段代码还支持可选的柯里 化(详情请查看之前和 bind(..) 相关的介绍)。</p>
<p>下面我们看看 softBind 是否实现了软绑定功能:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"name: "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">"obj"</span> &#125;, obj2 = &#123; <span class="attr">name</span>: <span class="string">"obj2"</span> &#125;, obj3 = &#123; <span class="attr">name</span>: <span class="string">"obj3"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> fooOBJ = foo.softBind( obj );</span><br><span class="line">fooOBJ(); <span class="comment">// name: obj</span></span><br><span class="line">obj2.foo = foo.softBind(obj);</span><br><span class="line">obj2.foo(); <span class="comment">// name: obj2 &lt;---- 看!!!</span></span><br><span class="line">fooOBJ.call( obj3 ); <span class="comment">// name: obj3 &lt;---- 看!</span></span><br><span class="line">setTimeout( obj2.foo, <span class="number">10</span> );</span><br><span class="line"><span class="comment">// name: obj &lt;---- 应用了软绑定</span></span><br></pre></td></tr></table></figure>
<p>可以看到，软绑定版本的 foo() 可以手动将 this 绑定到 obj2 或者 obj3 上，但如果应用默<br>认绑定，则会将 this 绑定到 obj。</p>
<h4 id="5-this词法"><a href="#5-this词法" class="headerlink" title="(5)this词法"></a>(5)this词法</h4><p>我们之前介绍的四条规则已经可以包含所有正常的函数。但是 ES6 中介绍了一种无法使用 这些规则的特殊函数类型:箭头函数。</p>
<h5 id="1-this的词法作用域"><a href="#1-this的词法作用域" class="headerlink" title="[1] this的词法作用域"></a>[1] this的词法作用域</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">   // 返回一个箭头函数</span><br><span class="line">   return () =&gt; &#123;</span><br><span class="line">   //this 继承自 foo()</span><br><span class="line">   console.log( this.a ); &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var obj1 = &#123; a:2 &#125;;</span><br><span class="line">var obj2 = &#123; a:3 &#125;;</span><br><span class="line"></span><br><span class="line">var bar = foo.call( obj1 );</span><br><span class="line">bar.call( obj2 ); // 2,不是3!</span><br></pre></td></tr></table></figure>
<p>foo() 内部创建的箭头函数会捕获调用时 foo() 的 this。由于 foo() 的 this 绑定到 obj1， bar(引用箭头函数)的 this 也会绑定到 obj1，箭头函数的绑定无法被修改。(new 也不 行!)</p>
<p>箭头函数最常用于回调函数中，例如事件处理器或者定时器:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">	setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;	<span class="comment">// 这里的 this 在此法上继承自 foo()</span>      <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );   &#125;,<span class="number">100</span>);&#125;<span class="keyword">var</span> obj = &#123; <span class="attr">a</span>:<span class="number">2</span>&#125;;foo.call( obj ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>箭头函数可以像 bind(..) 一样确保函数的 this 被绑定到指定对象，此外，其重要性还体 现在它用更常见的词法作用域取代了传统的 this 机制。</p>
<p>实际上，在 ES6 之前我们就已经 在使用一种几乎和箭头函数完全一样的模式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;	<span class="keyword">var</span> self = <span class="keyword">this</span>; <span class="comment">// lexical capture of this setTimeout( function()&#123;</span>    	<span class="built_in">console</span>.log( self.a );	&#125;, <span class="number">100</span> );&#125;<span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">2</span>&#125;;foo.call( obj ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>虽然 self = this 和箭头函数看起来都可以取代 bind(..)，但是从本质上来说，它们想替 代的是 this 机制。</p>
<p>如果你经常编写this风格的代码，但是绝大部分时候都会使用self = this或者箭头函数 来否定 this 机制，那你或许应当:</p>
<ol>
<li>只使用词法作用域并完全抛弃错误this风格的代码;</li>
<li>完全采用this风格，在必要时使用bind(..)，尽量避免使用self = this和箭头函数。</li>
</ol>
<p>当然，包含这两种代码风格的程序可以正常运行，但是在同一个函数或者同一个程序中混 合使用这两种风格通常会使代码更难维护，并且可能也会更难编写。</p>
<h3 id="this总结"><a href="#this总结" class="headerlink" title="this总结"></a>this总结</h3><p>（1）判断this的绑定</p>
<p>这个函数的直接调用位置。找到之后就可以顺序应用下面这四条规则来判断 this 的绑定对象。</p>
<p>四规则如下：</p>
<ol>
<li>由new调用，绑定到新创建的对象。</li>
<li>由call或者apply(或者bind)调用?绑定到指定的对象。</li>
<li>由上下文对象调用?绑定到那个上下文对象。</li>
<li>默认:在严格模式下绑定到undefined，否则绑定到全局对象。</li>
</ol>
<p>(2) 有些调用可能在无意中使用默认绑定规则。</p>
<ul>
<li>你可以使用一个DMZ对象，比如ø = Object.create(null)，以保护全局对象。</li>
</ul>
<p>(3) ES6 中的箭头函数并不会使用四条标准的绑定规则</p>
<p>箭头函数是根据当前的词法作用域来决定 this，具体来说，箭头函数会继承外层函数调用的 this 绑定(无论 this 绑定到什么)。这 其实和ES6之前代码中的self = this机制一样。</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://www.neohuang.com/child/2018/09/25/not-know-js-review-this/" data-id="cjmn38nqd001gujm7dkzib16w" class="article-share-link"><i class="fa fa-share"></i>Compartir</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            <!--
    
        <a href="http://www.neohuang.com/child/2018/09/25/not-know-js-review-this/#comments" class="article-comment-link">Comentarios</a>
    
-->
        </footer>
    </div>
    
</article>



    <article id="post-not-know-js-review-closure" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2018/09/19/not-know-js-review-closure/">你不知道的js复习笔记 (作用域闭包)</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2018/09/19/not-know-js-review-closure/">
            <time datetime="2018-09-18T16:00:00.000Z" itemprop="datePublished">2018-09-19</time>
        </a>
    </div>


                        
                        
                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h2 id="第一部分-作用域和闭包之函数作用域与块级作用域"><a href="#第一部分-作用域和闭包之函数作用域与块级作用域" class="headerlink" title="第一部分 作用域和闭包之函数作用域与块级作用域"></a>第一部分 作用域和闭包之函数作用域与块级作用域</h2><p>参考： 《你不知道的javascript—上卷》 第一部分</p>
<p>在读该章节前，发现是闭包，哎哟，又是你。。。。</p>
<h3 id="一、闭包实质"><a href="#一、闭包实质" class="headerlink" title="一、闭包实质"></a>一、闭包实质</h3><p><strong>书中定义</strong>：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用 域之外执行。</p>
<h4 id="1-闭包例子："><a href="#1-闭包例子：" class="headerlink" title="1.闭包例子："></a>1.闭包例子：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="keyword">var</span> a = <span class="number">2</span>;	<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">		<span class="built_in">console</span>.log( a );	&#125;	<span class="keyword">return</span> bar; </span><br><span class="line">&#125;<span class="keyword">var</span> baz = foo();baz(); <span class="comment">// 2 —— 朋友，这就是闭包的效果。</span></span><br></pre></td></tr></table></figure>
<p>函数 bar() 的词法作用域能够访问 foo() 的内部作用域。然后我们将 bar() 函数本身当作 一个值类型进行传递。在这个例子中，我们将 bar 所引用的函数对象本身当作返回值。</p>
<p><strong>执行过程：</strong></p>
<ul>
<li>foo() 执行</li>
<li>其返回值(也就是内部的 bar() 函数)赋值给变量 baz // bar函数可以记住并访问所在词法作用域</li>
<li>调用 baz()</li>
<li>执行bar() (在自己定义的词法作用域以外的地方 执行)</li>
</ul>
<p><strong>进一步解析</strong></p>
<ul>
<li><p>在 foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。由于看上去 foo() 的内容不会再被使用，所以很 自然地会考虑对其进行<strong>回收</strong>。</p>
</li>
<li><p>而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此 没有被回收。谁在使用这个内部作用域?原来是 bar() 本身在使用。</p>
</li>
<li><p>拜bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一 直存活，以供 bar() 在之后任何时间进行引用。<br>bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。</p>
</li>
</ul>
<h4 id="2-另外一个反例（某种意义上）"><a href="#2-另外一个反例（某种意义上）" class="headerlink" title="2.另外一个反例（某种意义上）"></a>2.另外一个反例（某种意义上）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">2</span>;	<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">		<span class="built_in">console</span>.log( a ); <span class="comment">// 2</span>	&#125;	bar(); </span><br><span class="line">&#125;foo();</span><br></pre></td></tr></table></figure>
<p>这是闭包吗?</p>
<p>技术上来讲，<strong>也许是</strong>。但根据前面的定义，<strong>确切地说并不是</strong>。</p>
<ul>
<li>foo() 执行</li>
<li>其返回值(也就是内部的 bar() 函数)赋值给变量 baz // bar函数可以记住并访问所在词法作用域</li>
<li>调用 baz()</li>
<li>执行bar() (没有在自己定义的词法作用域以外的地方 执行)</li>
</ul>
<h4 id="3-其他类型对函数类型的值进行传递的例子："><a href="#3-其他类型对函数类型的值进行传递的例子：" class="headerlink" title="3.其他类型对函数类型的值进行传递的例子："></a>3.其他类型对函数类型的值进行传递的例子：</h4><h5 id="1-通过回调传递"><a href="#1-通过回调传递" class="headerlink" title="(1)通过回调传递"></a>(1)通过回调传递</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">2</span>;	<span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">		<span class="built_in">console</span>.log( a ); <span class="comment">// 2</span>	&#125;	bar( baz ); </span><br><span class="line">&#125;<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">fn</span>) </span>&#123;	fn(); <span class="comment">// 妈妈快看呀，这就是闭包!</span>&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p><strong>执行过程：</strong></p>
<ul>
<li>foo()</li>
<li>bar()执行，并将baz引用通过回调的方式传递给bar作为回调执行 baz可以记住可以记住并访问所在词法作用域</li>
<li>bar()执行  (在自己定义的词法作用域以外的地方 执行)</li>
</ul>
<h5 id="2-间接传递参数"><a href="#2-间接传递参数" class="headerlink" title="(2)间接传递参数"></a>(2)间接传递参数</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn;<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;	<span class="keyword">var</span> a = <span class="number">2</span>;	<span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	 <span class="built_in">console</span>.log( a );	&#125;	fn = baz; <span class="comment">//将baz分配给全局变量 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;	fn(); <span class="comment">// 妈妈快看呀，这就是闭包!</span>&#125;foo();bar(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p><strong>执行过程：</strong></p>
<ul>
<li>foo()</li>
<li>fn = baz; 将baz分配给全局变量fn</li>
<li>bar()执行，fn即baz以记住可以记住并访问所在词法作用域</li>
<li>bar()执行  (即baz在自己定义的词法作用域以外的地方执行)</li>
</ul>
<h3 id="二、闭包无处不在"><a href="#二、闭包无处不在" class="headerlink" title="二、闭包无处不在"></a>二、闭包无处不在</h3><p>你已经写过的代码中一定到处都是闭包的身影。 现在让我们来搞懂这个事实。</p>
<p><strong>例子1:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">message</span>) </span>&#123;   setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;      <span class="built_in">console</span>.log( message );</span><br><span class="line">   &#125;, <span class="number">1000</span> ); </span><br><span class="line">&#125;</span><br><span class="line">      wait( <span class="string">"Hello, closure!"</span> );</span><br></pre></td></tr></table></figure>
<ul>
<li>wait() 执行</li>
<li>setTimeout执行 timer 具有涵盖 wait(..) 作用域，timer可以记住并访问所在词法作用域</li>
<li>timer()执行  (timer在自己定义的词法作用域以外的地方执行)</li>
</ul>
<p><strong>例子2</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupBot</span>(<span class="params">name, selector</span>) </span>&#123;	$( selector ).click( <span class="function"><span class="keyword">function</span> <span class="title">activator</span>(<span class="params"></span>) </span>&#123;      <span class="built_in">console</span>.log( <span class="string">"Activating: "</span> + name );	&#125;);&#125;</span><br><span class="line">setupBot( <span class="string">"Closure Bot 1"</span>, <span class="string">"#bot_1"</span> );setupBot( <span class="string">"Closure Bot 2"</span>, <span class="string">"#bot_2"</span> );</span><br></pre></td></tr></table></figure>
<ul>
<li>setupBot()执行</li>
<li>将activator函数，绑定到selector，activator可以记住并访问所在词法作用域（setupBot函数）</li>
<li>点击selector，执行activator函数，setupBot的作用域会保留，不会被回收 (activator在自己定义的词法作用域以外的地方执行)</li>
</ul>
<p><strong>总结：</strong></p>
<p>如果将函数(访问它们各自的词法作用域)当作第一 级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、 Ajax请求、跨窗口通信、Web Workers或者任何其他的异步(或者同步)任务中，只要使 用了回调函数，实际上就是在使用闭包!</p>
<h3 id="三、IIFE"><a href="#三、IIFE" class="headerlink" title="三、IIFE"></a>三、IIFE</h3><p>通常认为 IIFE 是典型的闭包例子，但根据先前对 闭包的定义，书上并不是很同意这个观点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">	<span class="built_in">console</span>.log( a );&#125;)();</span><br></pre></td></tr></table></figure>
<ul>
<li>虽然这段代码可以正常工作，但严格来讲它并不是闭包。</li>
<li>IIFE不是在它本身的词法作用域以外执行的。它在定义时所在的作用域中执行</li>
<li>a 是通过普通的词法作用域查找而非闭包被发 现的。</li>
</ul>
<h3 id="四、循环和闭包"><a href="#四、循环和闭包" class="headerlink" title="四、循环和闭包"></a>四、循环和闭包</h3><p>要说明闭包，for 循环是最常见的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123; </span><br><span class="line">	setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;      <span class="built_in">console</span>.log( i ); <span class="comment">// 输出5个6</span>   &#125;, i*<span class="number">1000</span> );&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行setTimeout</li>
<li>执行timer，通过作用域查找到i</li>
<li>返回结果</li>
</ul>
<p>正常情况下，我们对这段代码行为的预期是分别输出数字 1~5，每秒一次，每次一个。但实际上，这段代码在运行时会以每秒一次的频率输出五次 6。</p>
<p><strong>为什么会出现以上情况：</strong></p>
<p>缺陷是我们试图假设循环中的<strong>每个迭代在运行时都会给自己“捕获”一个 i</strong>的副本。但是 根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的， 但是它们都被封闭在一个共享的全局作用域中，因此实际上<strong>只有一个i</strong>。</p>
<p><strong>如果将代码改成这样：（依然失败）</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123; (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;	setTimeout( </span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	 		<span class="built_in">console</span>.log( i );   		&#125;, i*<span class="number">1000</span> );   &#125;)();&#125;</span><br></pre></td></tr></table></figure>
<p>结果依然不行，原因：</p>
<p>timer函数依然为从定义的词法作用域(IIFE)中获得i（实际i变量在上一次词法作用域中定义），如果作用域是空的，那么仅仅将它们进行封闭是不够的。</p>
<p><strong>如果将代码改成这样：（终于成功啦）</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123; </span><br><span class="line">	(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;		<span class="keyword">var</span> j = i;		setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;          <span class="built_in">console</span>.log( j );      &#125;, j*<span class="number">1000</span> );</span><br><span class="line">   &#125;)(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行IIFE</li>
<li>捕获i</li>
<li>setTimeout执行  即timer以记住可以记住并访问所在词法作用域（通过持有i的引用）</li>
<li>timer执行 </li>
</ul>
<p>进一步改造：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123; </span><br><span class="line">	(<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;		setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;          <span class="built_in">console</span>.log( j );      &#125;, j*<span class="number">1000</span> );</span><br><span class="line">   &#125;)(i ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原理同理</p>
<h3 id="五、重返块作用域"><a href="#五、重返块作用域" class="headerlink" title="五、重返块作用域"></a>五、重返块作用域</h3><p>仔细思考我们对前面的解决方案的分析。我们使用 IIFE 在每次迭代时都创建一个新的作用域。</p>
<p>实际我们可以使用let来转换成可关闭的作用域</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;	<span class="keyword">let</span> j = i; <span class="comment">// 是的，闭包的块作用域! </span></span><br><span class="line">	setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;      <span class="built_in">console</span>.log( j ); <span class="comment">// 1 2 3 4 5</span>   &#125;, j*<span class="number">1000</span> );&#125;</span><br></pre></td></tr></table></figure>
<p>更进一步：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i); <span class="comment">// 1 2 3 4</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for 循环头部的 let 声明还会有一 个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随 后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。</p>
<h3 id="六、模块"><a href="#六、模块" class="headerlink" title="六、模块"></a>六、模块</h3><p>还有其他的代码模式利用闭包的强大威力，但从表面上看，它们似乎与回调无关。下面一<br>起来研究其中最强大的一个:模块。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CoolModule</span>(<span class="params"></span>) </span>&#123;	<span class="keyword">var</span> something = <span class="string">"cool"</span>;</span><br><span class="line">	<span class="keyword">var</span> another = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">		<span class="built_in">console</span>.log( something );	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">doAnother</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( another.join( <span class="string">" ! "</span> ) );</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> &#123;		<span class="attr">doSomething</span>: doSomething, </span><br><span class="line">		doAnother: doAnother	&#125;;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = CoolModule(); </span><br><span class="line">foo.doSomething(); <span class="comment">// cool</span>foo.doAnother(); <span class="comment">// 1 ! 2 ! 3</span></span><br></pre></td></tr></table></figure>
<p>这个模式在 JavaScript 中被称为模块。最常见的实现模块模式的方法通常被称为模块暴露。</p>
<p>分析上述代码：</p>
<ul>
<li>CoolModule() 只是一个函数，必须要通过调用它来创建一个模块实例。如果不执行 外部函数，内部作用域和闭包都无法被创建。</li>
<li>CoolModule() 返回一个用对象字面量语法 { key: value, … } 来表示的对象。这 个返回的对象中含有对内部函数而不是内部数据变量的引用。我们保持内部数据变量是隐 藏且私有的状态。可以将这个对象类型的返回值看作本质上是模块的公共 API。</li>
<li>这个对象类型的返回值最终被赋值给外部的变量 foo，然后就可以通过它来访问 API 中的 属性方法 </li>
</ul>
<p>模块模式需要具备两个必要条件。</p>
<ol>
<li>必须有外部的封闭函数，该函数必须至少被调用一次(每次调用都会创建一个新的模块 实例)。</li>
<li>封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并 且可以访问或者修改私有的状态。</li>
</ol>
<p>一个具有函数属性的对象本身并不是真正的模块。从方便观察的角度看，一个从函数调用 所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。</p>
<h4 id="1-单例模块"><a href="#1-单例模块" class="headerlink" title="(1) 单例模块"></a>(1) 单例模块</h4><p>上一个示例代码中有一个叫作 CoolModule() 的独立的模块创建器，可以被调用任意多次， 每次调用都会创建一个新的模块实例。当只需要一个实例时，可以对这个模式进行简单的 改进来实现单例模式:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = (<span class="function"><span class="keyword">function</span> <span class="title">CoolModule</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"><span class="keyword">var</span> something = <span class="string">"cool"</span>;<span class="keyword">var</span> another = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];<span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">	<span class="built_in">console</span>.log( something );&#125;<span class="function"><span class="keyword">function</span> <span class="title">doAnother</span>(<span class="params"></span>) </span>&#123;	<span class="built_in">console</span>.log( another.join( <span class="string">" ! "</span> ) );&#125;<span class="keyword">return</span> &#123;	<span class="attr">doSomething</span>: doSomething,</span><br><span class="line">	doAnother: doAnother&#125;; &#125;)();foo.doSomething(); <span class="comment">// cool</span>foo.doAnother(); <span class="comment">// 1 ! 2 ! 3</span></span><br></pre></td></tr></table></figure>
<h4 id="2-模块接受参数"><a href="#2-模块接受参数" class="headerlink" title="(2)模块接受参数"></a>(2)模块接受参数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CoolModule</span>(<span class="params">id</span>) </span>&#123; <span class="function"><span class="keyword">function</span> <span class="title">identify</span>(<span class="params"></span>) </span>&#123;             <span class="built_in">console</span>.log( id );         &#125;<span class="keyword">return</span> &#123;<span class="attr">identify</span>: identify&#125;; &#125;<span class="keyword">var</span> foo1 = CoolModule( <span class="string">"foo 1"</span> ); <span class="keyword">var</span> foo2 = CoolModule( <span class="string">"foo 2"</span> );</span><br><span class="line">foo1.identify(); <span class="comment">// "foo 1"</span>foo2.identify(); <span class="comment">// "foo 2"</span></span><br></pre></td></tr></table></figure>
<h3 id="七、现代的模块机制"><a href="#七、现代的模块机制" class="headerlink" title="七、现代的模块机制"></a>七、现代的模块机制</h3><p>大多数模块依赖加载器 / 管理器本质上都是将这种模块定义封装进一个友好的 API。</p>
<p>典型例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyModules = (<span class="function"><span class="keyword">function</span> <span class="title">Manager</span>(<span class="params"></span>) </span>&#123;	<span class="keyword">var</span> modules = &#123;&#125;;	<span class="function"><span class="keyword">function</span> <span class="title">define</span>(<span class="params">name, deps, impl</span>) </span>&#123; <span class="comment">// name：模块名称 deps：依赖模块（数组） impl:实现</span>		<span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;deps.length; i++) &#123;               deps[i] = modules[deps[i]]; <span class="comment">// modules中寻找依赖模块</span>       &#125;       modules[name] = impl.apply( impl, deps );    &#125;	<span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">name</span>) </span>&#123; </span><br><span class="line">		<span class="keyword">return</span> modules[name];	&#125;	<span class="keyword">return</span> &#123;		<span class="attr">define</span>: define,		<span class="attr">get</span>: get </span><br><span class="line">	&#125;;&#125;)();</span><br></pre></td></tr></table></figure>
<p>这段代码的核心是modules[name] = impl.apply(impl, deps)。为了模块的定义引入了包装 函数(可以传入任何依赖)，并且将返回值，也就是模块的 API，储存在一个根据名字来管 理的模块列表中。</p>
<p>使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">MyModules.define( <span class="string">"bar"</span>, [], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"Let me introduce: "</span> + who; &#125;</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">     hello: hello</span><br><span class="line">   &#125;; &#125; );</span><br><span class="line"></span><br><span class="line"> MyModules.define( <span class="string">"foo"</span>, [<span class="string">"bar"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">bar</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> hungry = <span class="string">"hippo"</span>;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">awesome</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log( bar.hello( hungry ).toUpperCase() );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">     awesome: awesome</span><br><span class="line">   &#125;;</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> bar = MyModules.get( <span class="string">"bar"</span> );</span><br><span class="line"> <span class="keyword">var</span> foo = MyModules.get( <span class="string">"foo"</span> );</span><br><span class="line"> <span class="built_in">console</span>.log(</span><br><span class="line">     bar.hello( <span class="string">"hippo"</span> ),</span><br><span class="line">     foo.awesome(<span class="string">'dSADDA'</span>)</span><br><span class="line"> ); <span class="comment">// Let me introduce: hippo foo.awesome(); // LET ME INTRODUCE: HIPPO</span></span><br></pre></td></tr></table></figure>
<h3 id="八、未来的模块化机制"><a href="#八、未来的模块化机制" class="headerlink" title="八、未来的模块化机制"></a>八、未来的模块化机制</h3><p>es模块的一些存在的意义以及特点</p>
<ul>
<li><p>ES6 中为模块增加了一级语法支持。但通过模块系统进行加载时，ES6 会将文件当作独立 的模块来处理。每个模块都可以导入其他模块或特定的 API 成员，同样也可以导出自己的 API 成员。</p>
</li>
<li><p>基于函数的模块并不是一个能被稳定识别的模式(编译器无法识别)，它们 的 API 语义只有在运行时才会被考虑进来。因此可以在运行时修改一个模块 的 API(参考前面关于公共 API 的讨论)。</p>
</li>
<li><p>相比之下，ES6 模块 API 更加稳定(API 不会在运行时改变)。由于编辑器知 道这一点，因此可以在(的确也这样做了)编译期检查对导入模块的 API 成 员的引用是否真实存在。如果 API 引用并不存在，编译器会在运行时抛出一 个或多个“早期”错误，而不会像往常一样在运行期采用动态的解决方案。</p>
</li>
<li><p>ES6 的模块没有“行内”格式，必须被定义在独立的文件中(一个文件一个模块)。浏览 器或引擎有一个默认的“模块加载器”(可以被重载，但这远超出了我们的讨论范围)可 以在导入模块时异步地加载模块文件。</p>
</li>
</ul>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bar.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">who</span>) </span>&#123;	<span class="keyword">return</span> <span class="string">"Let me introduce: "</span> + who;&#125;<span class="keyword">export</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅从 "bar" 模块导入 hello() </span></span><br><span class="line"><span class="keyword">import</span> hello <span class="keyword">from</span> <span class="string">"bar"</span>;<span class="keyword">var</span> hungry = <span class="string">"hippo"</span>;<span class="function"><span class="keyword">function</span> <span class="title">awesome</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">	<span class="built_in">console</span>.log(hello( hungry ).toUpperCase());&#125;<span class="keyword">export</span> awesome;</span><br><span class="line"></span><br><span class="line"><span class="comment">// baz.js</span></span><br><span class="line"><span class="comment">// 导入完整的 "foo" 和 "bar" 模块</span></span><br><span class="line"> <span class="built_in">module</span> foo <span class="keyword">from</span> <span class="string">"foo"</span>; <span class="built_in">module</span> bar <span class="keyword">from</span> <span class="string">"bar"</span>; <span class="built_in">console</span>.log(bar.hello( <span class="string">"rhino"</span> )); <span class="comment">// Let me introduce: rhino</span> foo.awesome(); <span class="comment">// LET ME INTRODUCE: HIPPO</span></span><br></pre></td></tr></table></figure>
<p>import 可以将一个模块中的一个或多个 API 导入到当前作用域中，并分别绑定在一个变量 上(在我们的例子里是 hello)。module 会将整个模块的 API 导入并绑定到一个变量上(在 我们的例子里是 foo 和 bar)。export 会将当前模块的一个标识符(变量、函数)导出为公 共 API。这些操作可以在模块定义中根据需要使用任意多次。</p>
<p>模块文件中的内容会被当作好像包含在作用域闭包中一样来处理，就和前面介绍的函数闭 包模块一样。</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://www.neohuang.com/child/2018/09/19/not-know-js-review-closure/" data-id="cjmn38npy000sujm7q4xcbhmz" class="article-share-link"><i class="fa fa-share"></i>Compartir</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            <!--
    
        <a href="http://www.neohuang.com/child/2018/09/19/not-know-js-review-closure/#comments" class="article-comment-link">Comentarios</a>
    
-->
        </footer>
    </div>
    
</article>



    <article id="post-not-know-js-review-lexical-scope " class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2018/09/13/not-know-js-review-lexical-scope /">你不知道的js复习笔记 (词法作用域)</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2018/09/13/not-know-js-review-lexical-scope /">
            <time datetime="2018-09-12T16:00:00.000Z" itemprop="datePublished">2018-09-13</time>
        </a>
    </div>


                        
                        
                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h2 id="第一部分-作用域和闭包之词法作用域"><a href="#第一部分-作用域和闭包之词法作用域" class="headerlink" title="第一部分 作用域和闭包之词法作用域"></a>第一部分 作用域和闭包之词法作用域</h2><p>参考： 《你不知道的javascript—上卷》 第一部分    </p>
<h3 id="1-作用域工作模型类型"><a href="#1-作用域工作模型类型" class="headerlink" title="1.作用域工作模型类型"></a>1.作用域工作模型类型</h3><p>作用域共有两种主要的工作模型：</p>
<ul>
<li>词法作用域 ：javascript java</li>
<li>动态作用域 ： Bash, Perl的一部分</li>
</ul>
<h3 id="2-词法作用域"><a href="#2-词法作用域" class="headerlink" title="2.词法作用域"></a>2.词法作用域</h3><p>理解词法作用域及其名称来历，必须理解上篇复习里的编译器的第一个工作阶段叫作词法化的过程。</p>
<h4 id="1-概念："><a href="#1-概念：" class="headerlink" title="(1)概念："></a>(1)概念：</h4><p>简单地说，<strong>词法作用域就是定义在词法阶段的作用域。</strong></p>
<p>词法作用域是由你在写 代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function foo(a) &#123;</span><br><span class="line">	var b = a * 2;	function bar(c) &#123;</span><br><span class="line">	 console.log( a, b, c );	&#125;	bar( b * 3 ); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo( 2 ); // 2, 4, 12</span><br></pre></td></tr></table></figure>
<p>在这个例子中有三个逐级嵌套的作用域。</p>
<ul>
<li>(1) 全局作用域 包含:foo</li>
<li>(2) foo函数作用域 包含:a bar b </li>
<li>(3) bar函数作用域：c</li>
</ul>
<p>没有任何函数可以部分地同时出现在两个父级函数。</p>
<h4 id="2-和动态作用域的区别"><a href="#2-和动态作用域的区别" class="headerlink" title="(2) 和动态作用域的区别"></a>(2) 和动态作用域的区别</h4><p>这部分是书中没有提及的部分（我感觉书中没有直观的表现出词法作用域和动态作用域的区别）</p>
<ul>
<li><p><strong>词法作用域，函数的作用域在函数定义的时候就决定了。</strong></p>
</li>
<li><p><strong>动态作用域，函数的作用域是在函数调用的时候才决定的。</strong></p>
</li>
</ul>
<p>[1] 词法作用域</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">    foo(); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br></pre></td></tr></table></figure>
<p>[2] 动态作用域</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">value=1</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span> () &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$value</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">bar</span></span> () &#123;</span><br><span class="line">    <span class="built_in">local</span> value=2;</span><br><span class="line">    foo; ／／2</span><br><span class="line">&#125;</span><br><span class="line">bar</span><br></pre></td></tr></table></figure>
<h4 id="3-查找"><a href="#3-查找" class="headerlink" title="(3) 查找"></a>(3) 查找</h4><p>[1] 查找过程 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function foo(a) &#123;</span><br><span class="line">	var b = a * 2;	function bar(c) &#123;</span><br><span class="line">	 console.log( a, b, c );	&#125;	bar( b * 3 ); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo( 2 ); // 2, 4, 12</span><br></pre></td></tr></table></figure>
<p>在这个例子中有三个逐级嵌套的作用域。</p>
<ul>
<li>(1) 全局作用域 包含:foo</li>
<li>(2) foo函数作用域 包含:a bar b </li>
<li>(3) bar函数作用域：c</li>
</ul>
<p>以此例为例</p>
<p>查找a b c 3个变量，过程：</p>
<ul>
<li>执行foo函数</li>
<li>执行bar函数</li>
<li>查找变量 a bc =&gt; bar函数内找到 变量c,变量c标识符时停止</li>
<li>查找变量 a foo函数内找到 变量a,b,变量a,b标识符时停止</li>
</ul>
<p>js引擎会顺着作用域链向上查找变量，作用域查找会在找到第一个匹配的标识符时停止，在多层的嵌套作用域中可以定义同名的 标识符，这叫作“遮蔽效应”(内部的标识符“遮蔽”了外部的标识符)。抛开遮蔽效应， 作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见 第一个匹配的标识符为止。</p>
<p>[2] 函数的词法作用域只由函数被声明时所处 的位置决定</p>
<p>[3] 词法作用域查找只会查找一级标识符</p>
<p>比如 a、b 和 c。如果代码中引用了 foo.bar.baz， 词法作用域查找只会试图查找 foo 标识符，找到这个变量后，对象属性访问规则会分别接 管对 bar 和 baz 属性的访问。</p>
<h4 id="4-欺骗词法"><a href="#4-欺骗词法" class="headerlink" title="(4) 欺骗词法"></a>(4) 欺骗词法</h4><p>如果词法作用域完全由写代码期间函数所声明的位置来定义，怎样才能在运行时来“修<br>改”(也可以说欺骗)词法作用域呢?</p>
<p>JavaScript 中有两种机制来实现这个目的。社区普遍认为在代码中使用这两种机制并不是 什么好注意。但是关于它们的争论通常会忽略掉最重要的点:欺骗词法作用域会导致性能 下降。</p>
<h5 id="1-eval"><a href="#1-eval" class="headerlink" title="[1] eval"></a>[1] eval</h5><p><strong>原理：</strong>JavaScript 中的 eval(..) 函数可以接受一个字符串为参数，并将其中的内容视为好像在书 写时就存在于程序中这个位置的代码。</p>
<p>在执行 eval(..) 之后的代码时，引擎并不“知道”或“在意”前面的代码是以动态形式插 入进来，并对词法作用域的环境进行修改的。引擎只会如往常地进行词法作用域查找。</p>
<p>举例：</p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">str, a</span>) </span>{ 
<span class="built_in">eval</span>( str ); <span class="comment">// 欺骗! </span>
<span class="built_in">console</span>.log( a, b );
}
<span class="keyword">var</span> b = <span class="number">2</span>;
foo( <span class="string">"var b = 3;"</span>, <span class="number">1</span> ); <span class="comment">// 1, 3</span>
&lt;!--￼<span class="number">4</span>--&gt;

**注意事项：**

<span class="number">1.</span> setTimeout(..)和 setInterval(..) 也可以模拟类似效果

    他们的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的 函数代码。这些功能已经过时且并不被提倡。**不要使用它们!**

<span class="number">2.</span> <span class="keyword">new</span> <span class="built_in">Function</span>(..) 函数也可以模拟类似效果

    最后一个参数可以接受代码字符串，并将其转 化为动态生成的函数(前面的参数是这个新生成的函数的形参)。这种构建函数的语法比 <span class="built_in">eval</span>(..) 略微安全一些，**但也要尽量避免使用**。

在程序中动态生成代码的使用场景非常罕见，因为它所带来的好处无法抵消性能上的损失。

##### [2] with

<span class="keyword">with</span> 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象 本身。

例子：

&lt;!--￼<span class="number">5</span>--&gt;

可以利用这种特性实现：

&lt;!--￼<span class="number">6</span>--&gt;

这个例子中创建了 o1 和 o2 两个对象。其中一个具有 a 属性，另外一个没有。foo(..) 函 数接受一个obj参数，该参数是一个对象引用，并对这个对象引用执行了<span class="keyword">with</span>(obj) {..}。 在 <span class="keyword">with</span> 块内部，我们写的代码看起来只是对变量 a 进行简单的词法引用，实际上就是一个 LHS 引用(查看第 <span class="number">1</span> 章)，并将 <span class="number">2</span> 赋值给它。

**注意事项：**

- <span class="keyword">with</span> 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域

    &lt;!--￼<span class="number">7</span>--&gt;

- o2没有a这个属性，执行到a = <span class="number">2</span> 赋值操作创建了一个全局的变量 a。这里存在一个副作用
<span class="keyword">with</span> 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。

- 尽管 <span class="keyword">with</span> 块可以将一个对象处理为词法作用域，但是这个块内部正常的 <span class="keyword">var</span> 声明并不会被限制在这个块的作用域中，而是被添加到 <span class="keyword">with</span> 所处的函数作 用域中。

&lt;!--￼<span class="number">8</span>--&gt;

&lt;!--￼<span class="number">9</span>--&gt;

##### [3] eval和with区别

<span class="built_in">eval</span>(..) 函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域，而 <span class="keyword">with</span> 声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域。


##### [4] 性能

JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的 词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到 标识符。

因此<span class="built_in">eval</span>(..) 和 <span class="keyword">with</span>会带来**性能问题**原因：如果引擎在代码中发现了 <span class="built_in">eval</span>(..) 或 <span class="keyword">with</span>，它只能简单地假设关于标识符位置的判断 都是无效的，因为无法在词法分析阶段明确知道 <span class="built_in">eval</span>(..) 会接收到什么代码，这些代码会 如何对作用域进行修改，也无法知道传递给 <span class="keyword">with</span> 用来创建新词法作用域的对象的内容到底 是什么。


最悲观的情况是如果出现了 <span class="built_in">eval</span>(..) 或 <span class="keyword">with</span>，所有的优化可能都是无意义的，因此最简 单的做法就是完全不做任何优化。

### 重点总结

- 词法作用域意味着作用域是由书写代码时函数声明的位置来决定的
- 编译的词法分析阶段 基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它 们进行查找。
- JavaScript 中有两个机制可以“欺骗”词法作用域:<span class="built_in">eval</span>(..) 和 <span class="keyword">with</span>
- <span class="built_in">eval</span>可以对一段包 含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域
- <span class="keyword">with</span>本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作 用域中的标识符来处理，从而创建了一个新的词法作用域(同样是在运行时)
- 这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认 为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。不要使用它们。

### 补充知识 动态作用域

#### (1)词法作用域和动态作用域的区别

区别：

**词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的。**

原因：

**作用域链是基于调用栈的，而不是代码中的作用域嵌套。**

- 词法作用域是一套关于引擎如何寻找变量以及会在何处找到变量的规则。词法作用域最重要的特征是它的定义过程发生在代码的书写阶段。(假设你没有使用 <span class="built_in">eval</span>() 或 <span class="keyword">with</span>)。

- 动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从何处调用。换句话说，**作用域链是基于调用栈的，而不是代码中的作用域嵌套。**

&lt;!--￼<span class="number">10</span>--&gt;

为什么会动态作用域会输出<span class="number">3</span> ?因为当 foo() 无法找到 a 的变量引用时，会顺着调用栈在调用 foo() 的地 方查找 a，而不是在嵌套的词法作用域链中向上查找。由于 foo() 是在 bar() 中调用的， 引擎会检查 bar() 的作用域，并在其中找到值为 <span class="number">3</span> 的变量 a。

#### (2)和this相关的

事实上 JavaScript 并不具有动态作用域。它只有词法作用域，简单明了。 但是 <span class="keyword">this</span> 机制某种程度上很像动态作用域。

<span class="keyword">this</span> 关注函数如何调用，这就表明了 <span class="keyword">this</span> 机制和动态作用域之间的关系多么紧密。

### 补充知识 块作用域的替代方案

至少从 ES3 发布以来，JavaScript 中就有了块作用域，而 <span class="keyword">with</span> 和 <span class="keyword">catch</span> 分句就是块作用域的两个小例子。

但随着 ES6 中引入了 <span class="keyword">let</span>，我们的代码终于有了创建完整、不受约束的块作用域的能力。 块作用域在功能上和代码风格上都拥有很多激动人心的新特性。


但如果我们想在 ES6 之前的环境中使用块作用域呢?

例子：

&lt;!--￼<span class="number">11</span>--&gt;

es5转换

&lt;!--￼<span class="number">12</span>--&gt;

这么写可读性虽然不佳，可以通过工具转换，你可以使用块作用域来写代码，比如：Traceur

#### (1) 隐式和显式作用域

考虑下面这种 <span class="keyword">let</span> 的使用方法，它被称作 <span class="keyword">let</span> 作用域或 <span class="keyword">let</span> 声明(对比前面的 <span class="keyword">let</span> 定义)。

&lt;!--￼<span class="number">13</span>--&gt;

同隐式地劫持一个已经存在的作用域不同，<span class="keyword">let</span> 声明会创建一个显示的作用域并与其进行 绑定。显式作用域不仅更加突出，在代码重构时也表现得更加健壮。

但这种<span class="keyword">let</span> 声明并不包含在 ES6 中。官方的 Traceur 编译器也不接受这 种形式的代码。

可以使用这种办法来模拟实现：

&lt;!--￼<span class="number">14</span>--&gt;

#### (2) 性能

后简单地看一下 <span class="keyword">try</span>/<span class="keyword">catch</span> 带来的性能问题，并尝试回答“为什么不直接使用 IIFE 来创
建作用域”这个问题。

- <span class="keyword">try</span>/<span class="keyword">catch</span> 的性能的确很糟糕，但技术层面上没有合理的理由来说明 <span class="keyword">try</span>/<span class="keyword">catch</span> 必 须这么慢，或者会一直慢下去。自从 TC39 支持在 ES6 的转换器中使用 <span class="keyword">try</span>/<span class="keyword">catch</span> 后， Traceur 团队已经要求 Chrome 对 <span class="keyword">try</span>/<span class="keyword">catch</span> 的性能进行改进，他们显然有很充分的动机来 做这件事情。
- IIFE 和 <span class="keyword">try</span>/<span class="keyword">catch</span> 并不是完全等价的，因为如果将一段代码中的任意一部分拿出来 用函数进行包裹，会改变这段代码的含义，其中的 <span class="keyword">this</span>、<span class="keyword">return</span>、<span class="keyword">break</span> 和 contine 都会 发生变化。IIFE 并不是一个普适的解决方案，它只适合在某些情况下进行手动操作。
- 你是否想要块作用域?如果你想要，这些工具就可以帮助你。如果不 想要，继续使用 <span class="keyword">var</span> 来写代码就好了!

### 补充知识 this词法

ES6 中有一个主题用非常重要的方式将 <span class="keyword">this</span> 同词法作用域联系起来了

ES6 添加了一个特殊的语法形式用于函数声明，叫作箭头函数。它看起来是下面这样的:

&lt;!--￼<span class="number">15</span>--&gt;

但是箭头函数除了让你在声明函数时少敲几次键盘以外，还有更重要的作用

查看以下代码：

&lt;!--￼<span class="number">16</span>--&gt;

问题在于 cool() 函数丢失了同 <span class="keyword">this</span> 之间的绑定。解决这个问题有好几种办法，但最长用 的就是<span class="keyword">var</span> self = <span class="keyword">this</span>;。

&lt;!--￼<span class="number">17</span>--&gt;

ES6 中的箭头函数引入了一个叫作 <span class="keyword">this</span> 词法的行为,可以代替self：

&lt;!--￼<span class="number">18</span>--&gt;

简单来说，**箭头函数在涉及 <span class="keyword">this</span> 绑定时的行为和普通函数的行为完全不一致**。它放弃了所 有普通 <span class="keyword">this</span> 绑定的规则，取而代之的是用当前的词法作用域覆盖了 <span class="keyword">this</span> 本来的值。


解决这个“问题”的另一个更合适的办法是bind方法：

<span class="string">``</span><span class="string">`javascript</span>
<span class="string">var obj = { </span>
<span class="string">    count: 0,</span>
<span class="string">    cool: function coolFn() {</span>
<span class="string">         if (this.count &lt; 1) {</span>
<span class="string">            setTimeout( function timer(){ </span>
<span class="string">                this.count++; // this是安全的 // 因为 bind(..)</span>
<span class="string">                console.log( "more awesome" ); </span>
<span class="string">            }.bind( this ), 100 ); // look, bind()!</span>
<span class="string">        } </span>
<span class="string">    }</span>
<span class="string">};</span>
<span class="string">obj.cool(); // 更酷了。</span>
</code></pre>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://www.neohuang.com/child/2018/09/13/not-know-js-review-lexical-scope /" data-id="cjmn38nq60014ujm77f3z81g7" class="article-share-link"><i class="fa fa-share"></i>Compartir</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            <!--
    
        <a href="http://www.neohuang.com/child/2018/09/13/not-know-js-review-lexical-scope /#comments" class="article-comment-link">Comentarios</a>
    
-->
        </footer>
    </div>
    
</article>



    <article id="post-not-know-js-review-fp-scope-block-scope" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2018/09/13/not-know-js-review-fp-scope-block-scope/">你不知道的js复习笔记 (词法作用域)</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2018/09/13/not-know-js-review-fp-scope-block-scope/">
            <time datetime="2018-09-12T16:00:00.000Z" itemprop="datePublished">2018-09-13</time>
        </a>
    </div>


                        
                        
                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h2 id="第一部分-作用域和闭包之函数作用域与块级作用域"><a href="#第一部分-作用域和闭包之函数作用域与块级作用域" class="headerlink" title="第一部分 作用域和闭包之函数作用域与块级作用域"></a>第一部分 作用域和闭包之函数作用域与块级作用域</h2><p>参考： 《你不知道的javascript—上卷》 第一部分    </p>
<h3 id="1-函数中的作用域"><a href="#1-函数中的作用域" class="headerlink" title="1.函数中的作用域"></a>1.函数中的作用域</h3><h4 id="1-函数作用域的概念"><a href="#1-函数作用域的概念" class="headerlink" title="(1) 函数作用域的概念"></a>(1) 函数作用域的概念</h4><p>JavaScript 具有基于函数的作用域</p>
<p>函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复 用(事实上在嵌套的作用域中也可以使用)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">	<span class="comment">// some code</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="comment">// some code</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例就创建了2个函数作用域 foo() bar()以及一个全局用域，foo作用域包含了 a b bar c</p>
<p>bar(..) 拥有自己的作用域气泡。全局作用域也有自己的作用域气泡，它只包含了一个标 识符:foo。</p>
<h4 id="2-隐藏内部实现"><a href="#2-隐藏内部实现" class="headerlink" title="(2)隐藏内部实现"></a>(2)隐藏内部实现</h4><p>我们可以通过函数作用域来隐藏不想暴露给外部的方法，从而实现最小特权原则</p>
<p><strong>ps. 最小特权原则是指在软件设计中，应该最小限度地暴露必 要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。</strong></p>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function doSomething(a) &#123;	b = a + doSomethingElse( a * 2 );	console.log( b * 3 );&#125;function doSomethingElse(a) &#123; </span><br><span class="line">	return a - 1;&#125;var b;doSomething( 2 ); // 15</span><br></pre></td></tr></table></figure>
<p>实际没有必要暴露 var b 以及 doSomethingElse给到全局作用域</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">a</span>) </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">doSomethingElse</span>(<span class="params">a</span>) </span>&#123;		<span class="keyword">return</span> a - <span class="number">1</span>; </span><br><span class="line">	&#125;	<span class="keyword">var</span> b;	b = a + doSomethingElse( a * <span class="number">2</span> );   <span class="built_in">console</span>.log( b * <span class="number">3</span> ); &#125;     doSomething( <span class="number">2</span> ); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
<p>功能性和最终效果都没有受影响，但是设计上将具体内容私有化了，设计良好的软件都会 依此进行实现。</p>
<h4 id="3-规避冲突"><a href="#3-规避冲突" class="headerlink" title="(3)规避冲突"></a>(3)规避冲突</h4><p>“隐藏”作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a</span>) </span>&#123;		i = <span class="number">3</span>; <span class="comment">// 修改for循环所属作用域中的i</span>    	<span class="built_in">console</span>.log( a + i );       </span><br><span class="line">   &#125;	<span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;		bar( i * <span class="number">2</span> ); <span class="comment">// 糟糕，无限循环了!</span>	&#125; </span><br><span class="line">&#125;foo();</span><br></pre></td></tr></table></figure>
<h5 id="1-改名"><a href="#1-改名" class="headerlink" title="[1] 改名"></a>[1] 改名</h5><p>将i=0; 改为 j = 0，是软件设计在某种情况下可能自然 而然地要求使用同样的标识符名称，因此在这种情况下使用作用域来“隐藏”内部声明是 唯一的最佳选择。</p>
<h5 id="2-函数作用域隐藏"><a href="#2-函数作用域隐藏" class="headerlink" title="[2] 函数作用域隐藏"></a>[2] 函数作用域隐藏</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a</span>) </span>&#123;		<span class="keyword">var</span> i = <span class="number">3</span>; <span class="comment">// 修改for循环所属作用域中的i</span>    	<span class="built_in">console</span>.log( a + i );       </span><br><span class="line">   &#125;	<span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;		bar( i * <span class="number">2</span> ); <span class="comment">// 糟糕，无限循环了!</span>	&#125; </span><br><span class="line">&#125;foo();</span><br></pre></td></tr></table></figure>
<h5 id="3-全局命名空间"><a href="#3-全局命名空间" class="headerlink" title="[3] 全局命名空间"></a>[3] 全局命名空间</h5><p>变量冲突的一个典型例子存在于全局作用域中。当程序中加载了多个第三方库时,这些库通常会在全局作用域中声明一个名字足够独特的变量来作为命名空间，所有需要暴露给外界的功能都会成为这个对象(命名空间)的属 性，而不是将自己的标识符暴漏在顶级的词法作用域中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyReallyCoolLibrary = &#123;</span><br><span class="line"> awesome: <span class="string">"stuff"</span>, </span><br><span class="line"> doSomething: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;	<span class="comment">// ... </span></span><br><span class="line"> &#125;, <span class="attr">doAnotherThing</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;   <span class="comment">// ...</span>   函数作用域和块作用域 | <span class="number">25</span></span><br><span class="line"> &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="4-模块管理"><a href="#4-模块管理" class="headerlink" title="[4] 模块管理"></a>[4] 模块管理</h5><p>另外一种避免冲突的办法和现代的模块机制很接近，就是从众多模块管理器中挑选一个来 使用。使用这些工具，任何库都无需将标识符加入到全局作用域中，而是通过依赖管理器 的机制将库的标识符显式地导入到另外一个特定的作用域中。</p>
<h4 id="2-深入函数作用域"><a href="#2-深入函数作用域" class="headerlink" title="(2) 深入函数作用域"></a>(2) 深入函数作用域</h4><p><code>`</code><br>var a = 2;<br>function foo() {<br>     // &lt;– 添加这一行<br>    var a = 3;<br>    console.log( a ); // 3<br>}  // &lt;– 以及这一行<br>foo(); // &lt;– 以及这一行<br>console.log( a ); // 2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">这种方式通过foo，形成了一个函数作用域，完成了隐藏内部实现，但他仍存在两个问题</span><br><span class="line"></span><br><span class="line">1. 必须声明一个具名函数 foo()，意味着 foo 这个名称本身“污染”了所在作用域(</span><br><span class="line">2. 必须显式地通过函数名(foo())调用这个函数才能运行其 中的代码。</span><br><span class="line"></span><br><span class="line">JavaScript 提供了能够同时解决这两个问题的方案: IIFE</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">(function foo()&#123; // &lt;-- 添加这一行 var a = 3;	console.log( a ); // 3 </span><br><span class="line">&#125;)(); // &lt;-- 以及这一行 console.log( a ); // 2</span><br></pre></td></tr></table></figure></p>
<p>解析：</p>
<ul>
<li><p>包装函数的声明以 (function… 而不仅是以 function… ，因此是一个函数表达式，不是函数声明</p>
</li>
<li><p>两者区别第一个片段中 foo 被绑定在所在作用域中，第二个片段中 foo 被绑定在函数表达式自身的函数中而不是所在作用域中。</p>
</li>
<li>前者可以直接foo()调用，后者不可以</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">  console.log(123);</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">// 相当于</span><br><span class="line"></span><br><span class="line">var __ox123 = function() &#123;</span><br><span class="line">	console.log(123);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__ox123(); // 编译器无法直接调用 ,并且该函数由于是匿名的无法使用名称递归</span><br><span class="line"></span><br><span class="line"> (function foo()&#123;</span><br><span class="line">  console.log(123);</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"> var __ox234 = function() foo&#123;</span><br><span class="line">	console.log(234);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> __ox234(); 编译器无法直接调用 ,并且foo函数由于是具名的的无法使用名称递归</span><br></pre></td></tr></table></figure>
<p><strong>衍生知识 – 如何判断函数表达式和表述声明：</strong></p>
<p>function 关键字是声明中的一个词，就代表为函数声明语句，因此就是一个函数声明，否则就是一个函数表达式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 函数声明</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;) <span class="comment">//函数表达式</span></span><br><span class="line"></span><br><span class="line">-<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">//函数表达式</span></span><br></pre></td></tr></table></figure>
<h4 id="3-匿名和具名函数"><a href="#3-匿名和具名函数" class="headerlink" title="(3) 匿名和具名函数"></a>(3) 匿名和具名函数</h4><p>[1] 匿名函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;         <span class="built_in">console</span>.log(<span class="string">"I waited 1 second!"</span>);&#125;, <span class="number">1000</span> );</span><br></pre></td></tr></table></figure>
<p><strong>这叫作匿名函数表达式，因为 function().. 没有名称标识符。函数表达式可以是匿名的，<br>而函数声明则不可以省略函数名——在 JavaScript 的语法中这是非法的。</strong></p>
<p>缺点：</p>
<ul>
<li>匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。</li>
<li>如果没有函数名，当函数需要引用自身时只能使用已经过期的arguments.callee引用， 比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑 自身。</li>
<li>匿名函数省略了对于代码可读性/可理解性很重要的函数名。一个描述性的名称可以让 代码不言自明。</li>
</ul>
<p>[2] 行内函数表达式</p>
<p>行内函数表达式非常强大且有用——匿名和具名之间的区别并不会对这点有任何影响。给函 数表达式指定一个函数名可以有效解决以上问题。始终给函数表达式命名是一个最佳实践:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout( function timeoutHandler() &#123;</span><br><span class="line"> // &lt;-- 快看，我有名字了! </span><br><span class="line"> console.log( &quot;I waited 1 second!&quot; );&#125;, 1000 );</span><br></pre></td></tr></table></figure>
<h4 id="4-立即执行函数"><a href="#4-立即执行函数" class="headerlink" title="(4) 立即执行函数"></a>(4) 立即执行函数</h4><h5 id="1-IIFE"><a href="#1-IIFE" class="headerlink" title="[1] IIFE"></a>[1] IIFE</h5><p>IIFE，代表立即执行函数表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = 2;(function foo() &#123;</span><br><span class="line"> var a = 3; console.log( a ); // 3      </span><br><span class="line">&#125;)(); console.log( a ); // 2</span><br></pre></td></tr></table></figure>
<p>由于函数被包含在一对 ( ) 括号内部，因此成为了一个表达式，通过在末尾加上另外一个 ( ) 可以立即执行这个函数，比如 (function foo(){ .. })()。第一个 ( ) 将函数变成表 达式，第二个 ( ) 执行了这个函数。</p>
<p>相较于传统的 IIFE 形式，很多人都更喜欢另一个改进的形式:(function(){ .. }())，这两种形式在功能上是一致的。选择哪个全凭个人喜好。</p>
<h5 id="2-传递参数"><a href="#2-传递参数" class="headerlink" title="[2] 传递参数"></a>[2] 传递参数</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"> global </span>) </span>&#123;	<span class="keyword">var</span> a = <span class="number">3</span>;	<span class="built_in">console</span>.log( a ); <span class="comment">// 3 console.log( global.a ); // 2</span>&#125;)( <span class="built_in">window</span> );<span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>我们将 window 对象的引用传递进去，但将参数命名为 global，可以从外部作用域传递任何你需要的东西，并将变量命名为任何你觉得合适的名字这对于改进代码风格是非 常有帮助的。</p>
<h5 id="3-解决undefined标识符的默认值被错误覆盖导致的异常"><a href="#3-解决undefined标识符的默认值被错误覆盖导致的异常" class="headerlink" title="[3]解决undefined标识符的默认值被错误覆盖导致的异常"></a>[3]解决undefined标识符的默认值被错误覆盖导致的异常</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span> = <span class="literal">true</span>; <span class="comment">// 给其他代码挖了一个大坑!绝对不要这样做! (function IIFE( undefined ) &#123;</span>	<span class="keyword">var</span> a;	<span class="keyword">if</span> (a === <span class="literal">undefined</span>) &#123;         <span class="built_in">console</span>.log( <span class="string">"Undefined is safe here!"</span> );   &#125;&#125;)();</span><br></pre></td></tr></table></figure>
<h5 id="4-倒置代码的运行顺序"><a href="#4-倒置代码的运行顺序" class="headerlink" title="[4]倒置代码的运行顺序"></a>[4]倒置代码的运行顺序</h5><p>IFE 还有一种变化的用途是倒置代码的运行顺序，将需要运行的函数放在第二位，在 IIFE 执行之后当作参数传递进去。这种模式在 UMD(Universal Module Definition)项目中被广 泛使用。尽管这种模式略显冗长，但有些人认为它更易理解。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;<span class="comment">// 函数作用域和块作用域 | 29</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"> def </span>) </span>&#123; </span><br><span class="line">	def( <span class="built_in">window</span> );&#125;)(<span class="function"><span class="keyword">function</span> <span class="title">def</span>(<span class="params"> global </span>) </span>&#123;	<span class="keyword">var</span> a = <span class="number">3</span>;	<span class="built_in">console</span>.log( a ); <span class="comment">// 3 console.log( global.a ); // 2</span>&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="5-块作用域"><a href="#5-块作用域" class="headerlink" title="(5) 块作用域"></a>(5) 块作用域</h4><p>尽管函数作用域是最常见的作用域单元，但其他类型的作用域单元也是存在的</p>
<p>js中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123; </span><br><span class="line">	<span class="built_in">console</span>.log( i ); <span class="regexp">/ 1 2 3 4 5 6 7 8 9&#125;</span></span><br><span class="line"><span class="regexp">console.log(i); /</span><span class="regexp">/ 10</span></span><br></pre></td></tr></table></figure>
<p>c++中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">1</span>;	</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; i; / <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line">   &#125;</span><br><span class="line">	</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; i; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>块作用域是一个用来对之前的最小授权原则进行扩展的工具，将代码从在函数中隐藏信息 扩展为在块中隐藏信息。</p>
<h5 id="1-js中的块级作用域"><a href="#1-js中的块级作用域" class="headerlink" title="[1] js中的块级作用域"></a>[1] js中的块级作用域</h5><p>表面上看 JavaScript 并没有块作用域的相关功能,除非你更加深入地研究。</p>
<h6 id="1-with"><a href="#1-with" class="headerlink" title="(1) with"></a>(1) with</h6><p>之前有提过with会生成一个词法作用域，因为with本身之后{}是一个语句块，因此用 with 从对象中创建出的作用域仅在 with 声明中而非外 部作用域中有效。</p>
<h6 id="2-try-catch"><a href="#2-try-catch" class="headerlink" title="(2) try/catch"></a>(2) try/catch</h6><p>JavaScript 的 ES3 规范中规定 try/catch 的 catch 分句会创建一个块作<br>用域，其中声明的变量仅在 catch 内部有效。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;	<span class="literal">undefined</span>(); <span class="comment">// 执行一个非法操作来强制制造一个异常</span>&#125;<span class="keyword">catch</span> (err) &#123;	<span class="built_in">console</span>.log( err ); <span class="comment">// 能够正常执行! </span></span><br><span class="line">&#125;<span class="built_in">console</span>.log( err ); <span class="comment">// ReferenceError: err not found</span></span><br></pre></td></tr></table></figure>
<h6 id="3-let"><a href="#3-let" class="headerlink" title="(3) let"></a>(3) let</h6><ol>
<li>块级作用域</li>
</ol>
<p>ES6 改变了现状，引入了新的 let 关键字，提供了除 var 以外的另一种变量声明方式。</p>
<ul>
<li>隐式声明：</li>
</ul>
<p><code>`</code>javascript<br>var foo = true;<br>if (foo) {<br>    let bar = foo * 2;<br>    bar = something( bar );<br>    console.log( bar );<br>}<br>console.log( bar ); // ReferenceError<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 显示声明：</span><br><span class="line"></span><br><span class="line">显式地创建块可以部分解决这个问题，可以使变量的附属关系变得更加清晰。</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">var foo = true;</span><br><span class="line">if (foo) &#123;	&#123; // &lt;-- 显式的快		let bar = foo * 2;		bar = something( bar ); console.log( bar );	&#125; </span><br><span class="line">&#125;console.log( bar ); // ReferenceError</span><br></pre></td></tr></table></figure></p>
<p>2.不存在变量提升</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( bar ); <span class="comment">// ReferenceError! </span></span><br><span class="line">	<span class="keyword">let</span> bar = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.垃圾收集方面使用let带来的好处</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">data</span>) </span>&#123;<span class="comment">// 在这里做点有趣的事情</span>&#125;	<span class="keyword">var</span> someReallyBigData = &#123; .. &#125;;	process( someReallyBigData );	<span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById( <span class="string">"my_button"</span> );</span><br><span class="line">	<span class="comment">// 此处由于dom引用了process中的监听，形成了闭包</span>   btn.addEventListener( <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params">evt</span>) </span>&#123;          <span class="built_in">console</span>.log(<span class="string">"button clicked"</span>);	&#125;, <span class="comment">/*capturingPhase=*/</span><span class="literal">false</span> );</span><br></pre></td></tr></table></figure>
<p>实际click 函数的点击回调并不需要 someReallyBigData 变量。理论上这意味着当 process(..) 执 行后，在内存中占用大量空间的数据结构就可以被垃圾回收了。但是，由于 click 函数形成 了一个覆盖整个作用域的闭包，JavaScript 引擎极有可能依然保存着这个结构(取决于具体 实现)。</p>
<p>如果使用了块作用域：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">data</span>) </span>&#123;	<span class="comment">// 在这里做点有趣的事情</span>&#125;<span class="comment">// 在这个块中定义的内容可以销毁了! </span></span><br><span class="line">&#123;	<span class="keyword">let</span> someReallyBigData = &#123;</span><br><span class="line">		 .. </span><br><span class="line">	&#125;; </span><br><span class="line">	process( someReallyBigData );&#125;<span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById( <span class="string">"my_button"</span> );btn.addEventListener( <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params">evt</span>)</span>&#123;   <span class="built_in">console</span>.log(<span class="string">"button clicked"</span>);</span><br><span class="line">&#125;, <span class="comment">/*capturingPhase=*/</span><span class="literal">false</span> );</span><br></pre></td></tr></table></figure>
<p>4.let循环</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123; </span><br><span class="line">	<span class="built_in">console</span>.log( i );&#125; <span class="built_in">console</span>.log( i ); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>
<p>for 循环头部的 let 不仅将 i 绑定到了 for 循环的块中，事实上它将其重新绑定到了循环 的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;	<span class="keyword">let</span> j;	<span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++) &#123;		<span class="keyword">let</span> i = j; <span class="comment">// 每个迭代重新绑定!</span>    	<span class="built_in">console</span>.log( i );  	&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>由于 let 声明附属于一个新的作用域而不是当前的函数作用域(也不属于全局作用域)，可能会存在很多陷阱：</p>
<p>例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>, baz = <span class="number">10</span>; </span><br><span class="line"><span class="keyword">if</span> (foo) &#123;	<span class="keyword">var</span> bar = <span class="number">3</span>;	<span class="keyword">if</span> (baz &gt; bar) &#123;</span><br><span class="line">	 <span class="built_in">console</span>.log( baz );	&#125;		<span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以重构成</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>, baz = <span class="number">10</span>; </span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">	<span class="keyword">var</span> bar = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (baz &gt; bar) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'baz'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但如果是用了let</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>, baz = <span class="number">10</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">	<span class="keyword">let</span> bar = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">if</span> (baz &gt; bar) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'baz'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-另外一种块作用域形式"><a href="#5-另外一种块作用域形式" class="headerlink" title="(5)另外一种块作用域形式"></a>(5)另外一种块作用域形式</h4><h4 id="6-const"><a href="#6-const" class="headerlink" title="(6)const"></a>(6)const</h4><p>除了 let 以外，ES6 还引入了 const，同样可以用来创建块作用域变量，但其值是固定的 (常量)。之后任何试图修改值的操作都会引起错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;<span class="keyword">if</span> (foo) &#123;	<span class="keyword">var</span> a = <span class="number">2</span>;	<span class="keyword">const</span> b = <span class="number">3</span>; <span class="comment">// 包含在 if 中的块作用域常量</span>	a = <span class="number">3</span>; <span class="comment">// 正常!</span>	b = <span class="number">4</span>; <span class="comment">// 错误! </span></span><br><span class="line">&#125;<span class="built_in">console</span>.log( a ); <span class="comment">// 3</span><span class="built_in">console</span>.log( b ); <span class="comment">// ReferenceError!</span></span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>
        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://www.neohuang.com/child/2018/09/13/not-know-js-review-fp-scope-block-scope/" data-id="cjmn38nq20010ujm7iejd1xdf" class="article-share-link"><i class="fa fa-share"></i>Compartir</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            <!--
    
        <a href="http://www.neohuang.com/child/2018/09/13/not-know-js-review-fp-scope-block-scope/#comments" class="article-comment-link">Comentarios</a>
    
-->
        </footer>
    </div>
    
</article>



    <article id="post-not-know-js-review-function-hosting" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2018/09/13/not-know-js-review-function-hosting/">你不知道的js复习笔记 (提升)</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2018/09/13/not-know-js-review-function-hosting/">
            <time datetime="2018-09-12T16:00:00.000Z" itemprop="datePublished">2018-09-13</time>
        </a>
    </div>


                        
                        
                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h2 id="第一部分-提升"><a href="#第一部分-提升" class="headerlink" title="第一部分 提升"></a>第一部分 提升</h2><p>参考： 《你不知道的javascript—上卷》 第一部分</p>
<p>直觉上会认为 JavaScript 代码在执行时是由上到下一行一行执行的。但实际上这并不完全正确。</p>
<h3 id="1-变量提升"><a href="#1-变量提升" class="headerlink" title="(1) 变量提升"></a>(1) 变量提升</h3><p>这是javascript中的变量提升</p>
<p>例子1:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">2</span>;<span class="keyword">var</span> a; </span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>例子2：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( a );</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h3 id="2-变量提升和编译器"><a href="#2-变量提升和编译器" class="headerlink" title="(2) 变量提升和编译器"></a>(2) 变量提升和编译器</h3><h4 id="1-声明提前"><a href="#1-声明提前" class="headerlink" title="[1] 声明提前"></a>[1] 声明提前</h4><p>变量提升的背后和第一章的编译器有密切的关系，引擎会 在解释 JavaScript 代码之前首先对其进行编译。编译阶段中的一部分工作就是找到所有的 声明，并用合适的作用域将它们关联起来。</p>
<p>因此，我们在分析js代码的时候正确的思考思路是，包括变量和函数在内的所有声明都会在任何代码被执行前首先 被处理。</p>
<p>当你看到 var a = 2; 时，可能会认为这是一个声明。但 JavaScript 实际上会将其看成<strong>两个声明</strong>:var a;和a = 2;。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在 原地等待执行阶段。</p>
<p>例子1实际在编译器中会这样执行:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;a=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log( a );</span><br></pre></td></tr></table></figure>
<p>例子2:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;<span class="built_in">console</span>.log( a );</span><br><span class="line">a=<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>其中第一部分是编译，而第二部分是执行。</p>
<p>因此，打个比方，这个过程就好像变量和函数声明从它们在代码中出现的位置被“移动” 到了最上面。这个过程就叫作提升。</p>
<p><strong>换句话说，先声明，后赋值</strong></p>
<h4 id="2-函数执行不会被提前"><a href="#2-函数执行不会被提前" class="headerlink" title="[2]  函数执行不会被提前"></a>[2]  函数执行不会被提前</h4><p>只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变了代码执行的顺序，会造成非常严重的破坏。</p>
<h4 id="3-每个作用域都会声明提升"><a href="#3-每个作用域都会声明提升" class="headerlink" title="[3] 每个作用域都会声明提升"></a>[3] 每个作用域都会声明提升</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// 会将 foo声明提升</span><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( a );  <span class="comment">// 会将 变量a声明提升</span></span><br><span class="line">	<span class="comment">// undefined var a =2;</span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-函数声明会被提升，但是函数表达式却不会被提升"><a href="#4-函数声明会被提升，但是函数表达式却不会被提升" class="headerlink" title="[4] 函数声明会被提升，但是函数表达式却不会被提升"></a>[4] 函数声明会被提升，但是函数表达式却不会被提升</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// 不是 ReferenceError, 而是 TypeError!</span><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="comment">// ...</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>实际是 foo 会提升，但是 foo 此时并没有赋值(如果它是一个函数声明而不 是函数表达式，那么就会赋值)。foo() 由于对 undefined 值进行函数调用而导致非法操作， 因此抛出 TypeError 异常。</p>
<h4 id="5-函数声明会被提升，但是函数表达式却不会被提升"><a href="#5-函数声明会被提升，但是函数表达式却不会被提升" class="headerlink" title="[5] 函数声明会被提升，但是函数表达式却不会被提升"></a>[5] 函数声明会被提升，但是函数表达式却不会被提升</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// TypeError</span>bar(); <span class="comment">// ReferenceError</span><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">	<span class="comment">// ...</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>这个代码片段经过提升后，实际上会被理解为以下形式:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo;foo(); <span class="comment">// TypeError</span>bar(); <span class="comment">// ReferenceError</span>foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">var</span> bar = ...self... </span><br><span class="line"><span class="comment">// ...</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-函数优先"><a href="#3-函数优先" class="headerlink" title="(3) 函数优先"></a>(3) 函数优先</h3><h4 id="1-函数声明和变量声明都会被提升-函数会首先被提升，然后才是变量"><a href="#1-函数声明和变量声明都会被提升-函数会首先被提升，然后才是变量" class="headerlink" title="[1] 函数声明和变量声明都会被提升,函数会首先被提升，然后才是变量"></a>[1] 函数声明和变量声明都会被提升,函数会首先被提升，然后才是变量</h4><p>函数声明和变量声明都会被提升。但是一个值得注意的细节(这个细节可以出现在有多个<br>“重复”声明的代码中)是函数会首先被提升，然后才是变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// 执行1</span><span class="keyword">var</span> foo;<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">	<span class="built_in">console</span>.log( <span class="number">1</span> );&#125;foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log( <span class="number">2</span> );&#125;;</span><br></pre></td></tr></table></figure>
<p>实际可以看成这样:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo <span class="comment">// 重复声明被忽略</span></span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-重复的-var-声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。"><a href="#2-重复的-var-声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。" class="headerlink" title="[2]重复的 var 声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。"></a>[2]重复的 var 声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// 3</span><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log( <span class="number">1</span> );&#125;<span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">	<span class="built_in">console</span>.log( <span class="number">2</span> );&#125;;<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">	<span class="built_in">console</span>.log( <span class="number">3</span> );&#125;</span><br></pre></td></tr></table></figure>
<p>实际转换成了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log( <span class="number">1</span> );&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">	<span class="built_in">console</span>.log( <span class="number">3</span> );&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">	<span class="built_in">console</span>.log( <span class="number">2</span> );&#125;;</span><br></pre></td></tr></table></figure>
<p>判断不要这么用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// "b"</span><span class="keyword">var</span> a = <span class="literal">true</span>; </span><br><span class="line"><span class="keyword">if</span>(a)&#123;	<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">"a"</span>); &#125; &#125;<span class="keyword">else</span> &#123;	<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">"b"</span>); &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>但是需要注意这个行为并不可靠，在 JavaScript 未来的版本中有可能发生改变，因此应该 尽可能避免在块内部声明函数。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>var a = 2;可以看作2个阶段 var a; a=2,第一个是编译阶段的任务，而第二个则是执行阶段的任务。</li>
<li><p>无论作用域中的声明出现在什么地方，所有的声明(变量和函数)都会被“移动”到各自作用域的 最顶端，这个过程被称为提升。</p>
</li>
<li><p>声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。</p>
</li>
<li>要注意避免重复声明，特别是当普通的 var 声明和函数声明混合在一起的时候</li>
</ul>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://www.neohuang.com/child/2018/09/13/not-know-js-review-function-hosting/" data-id="cjmn38nq0000wujm79iijfx2j" class="article-share-link"><i class="fa fa-share"></i>Compartir</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            <!--
    
        <a href="http://www.neohuang.com/child/2018/09/13/not-know-js-review-function-hosting/#comments" class="article-comment-link">Comentarios</a>
    
-->
        </footer>
    </div>
    
</article>



    <article id="post-array-review" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2018/09/12/array-review/">js数组方法分类复习</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2018/09/12/array-review/">
            <time datetime="2018-09-11T16:00:00.000Z" itemprop="datePublished">2018-09-12</time>
        </a>
    </div>


                        
                        
                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>年纪大了，每过一段时间都记不住数组的基本方法，所以经常要自己做一个review（这篇先占位之后好好再复习）</p>
<h3 id="一、数组"><a href="#一、数组" class="headerlink" title="一、数组"></a>一、数组</h3><h4 id="1-检测数组"><a href="#1-检测数组" class="headerlink" title="(1) 检测数组"></a>(1) 检测数组</h4><ul>
<li><p>value instanceof Array</p>
</li>
<li><p>Array.isArray</p>
</li>
</ul>
<h4 id="2-转换方法"><a href="#2-转换方法" class="headerlink" title="(2) 转换方法"></a>(2) 转换方法</h4><ul>
<li><p>toString</p>
</li>
<li><p>toLocalString</p>
</li>
<li><p>toValue</p>
</li>
</ul>
<h4 id="3-栈方法"><a href="#3-栈方法" class="headerlink" title="(3) 栈方法"></a>(3) 栈方法</h4><ul>
<li>push (改变原数组)</li>
<li>pop （改变原数组）</li>
</ul>
<h4 id="4-队列方法"><a href="#4-队列方法" class="headerlink" title="(4) 队列方法"></a>(4) 队列方法</h4><ul>
<li>unshift （改变原数组）</li>
<li>shift （改变原数组）</li>
</ul>
<h4 id="5-排序方法"><a href="#5-排序方法" class="headerlink" title="(5) 排序方法"></a>(5) 排序方法</h4><ul>
<li>sort （改变原数组）</li>
<li>reverse(改变原数组)</li>
</ul>
<h4 id="6-操作方法"><a href="#6-操作方法" class="headerlink" title="(6) 操作方法"></a>(6) 操作方法</h4><ul>
<li>concat</li>
<li>slice </li>
<li>join</li>
<li>splice (改变原数组)</li>
</ul>
<h4 id="7-位置方法"><a href="#7-位置方法" class="headerlink" title="(7) 位置方法"></a>(7) 位置方法</h4><ul>
<li>indexOf</li>
<li>lastIndexOf</li>
</ul>
<h4 id="8-迭代方法"><a href="#8-迭代方法" class="headerlink" title="(8) 迭代方法"></a>(8) 迭代方法</h4><ul>
<li>every  （有返回值）</li>
<li>filter （有返回值）</li>
<li>forEach （没有返回值）</li>
<li>map （有返回值）</li>
<li>some （有返回值）</li>
</ul>
<h4 id="9-归并方法"><a href="#9-归并方法" class="headerlink" title="(9) 归并方法"></a>(9) 归并方法</h4><ul>
<li><p>reduce （有返回值）</p>
</li>
<li><p>reduceRight （有返回值）</p>
</li>
</ul>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://www.neohuang.com/child/2018/09/12/array-review/" data-id="cjmn38npc0006ujm7l4joepto" class="article-share-link"><i class="fa fa-share"></i>Compartir</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            <!--
    
        <a href="http://www.neohuang.com/child/2018/09/12/array-review/#comments" class="article-comment-link">Comentarios</a>
    
-->
        </footer>
    </div>
    
</article>



    <article id="post-not-know-js-review-base-scope" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2018/09/12/not-know-js-review-base-scope/">你不知道的js复习笔记 (什么是作用域)</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2018/09/12/not-know-js-review-base-scope/">
            <time datetime="2018-09-11T16:00:00.000Z" itemprop="datePublished">2018-09-12</time>
        </a>
    </div>


                        
                        
                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h2 id="第一部分-作用域和闭包之什么是作用域"><a href="#第一部分-作用域和闭包之什么是作用域" class="headerlink" title="第一部分 作用域和闭包之什么是作用域"></a>第一部分 作用域和闭包之什么是作用域</h2><p>参考： 《你不知道的javascript—上卷》 第一部分    </p>
<h3 id="1-作用域"><a href="#1-作用域" class="headerlink" title="1.作用域"></a>1.作用域</h3><h4 id="1-作用域概念"><a href="#1-作用域概念" class="headerlink" title="1.作用域概念"></a>1.作用域概念</h4><p>一套来规定存储、读取变量的规则，解释器根据该规则来存储以及读取变量。</p>
<h4 id="2-编译原理"><a href="#2-编译原理" class="headerlink" title="2.编译原理"></a>2.编译原理</h4><h5 id="1-js语言特性："><a href="#1-js语言特性：" class="headerlink" title="(1) js语言特性："></a>(1) js语言特性：</h5><p>js归类为“动态”或“解释型语言”，但事实上它仍是一门编译语言</p>
<p><strong>衍生知识：</strong></p>
<p>前置知识：</p>
<p>运行期间：当程序在内存中的时候，就是运行时,其余时候都是在磁盘上，都不是运行时 (不一定在全部编译后，解释型语言可能会动态编译)</p>
<p>改变其结构：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。<br>（等待js元编程章节再探讨）</p>
<p>(1) 动态语言和静态语言的区别 （容易混淆）：</p>
<ul>
<li><p><strong>动态语言：</strong>指运行期间可以改变其结构的语言</p>
</li>
<li><p><strong>静态语言：</strong>与动态语言相反，在运行时不能改变其结构 （虽然尽管静态语言可以通过复杂的手段实现动态语言的特性，但是动态语言提供了直接的方法实现语言的动态性。）</p>
</li>
</ul>
<p>(2) 动态类型语言和静态类型语言区别 （容易混淆）：</p>
<ul>
<li><p><strong>动态类型语言：</strong>指在运行期间才去做数据类型检查的语言</p>
</li>
<li><p><strong>静态类型语言：</strong>与动态类型语言刚好相反，它的数据类型检查发生在在编译阶段。（静态语言通常会使用泛型去实现，实现其动态性    ）</p>
</li>
</ul>
<p>(3) 强类语言和弱类语言区别：</p>
<ul>
<li><strong>强类型语言：</strong> 偏向于不容忍隐式类型转换的语言</li>
<li><strong>弱类型语言:</strong> 偏向于容忍隐式类型转换的语言</li>
</ul>
<p>(4) 解释型语言和编译型语言区别：</p>
<ul>
<li><strong>解释型类型语言：</strong>  是一种以用解释器来实现的编程语言，在执行期，动态将程式码逐句解释（interpret）为机器码，或是已经预先编译为机器码的的子程式，之后再执行。</li>
<li><strong>编译型语言：</strong> 是一种以编译器来实现的编程语言，以编译器，先将代码编译为机器码，再加以运行。</li>
</ul>
<h5 id="2-编译型语言的编译过程："><a href="#2-编译型语言的编译过程：" class="headerlink" title="(2) 编译型语言的编译过程："></a>(2) 编译型语言的编译过程：</h5><p>[1] 分词/词法分析 （Tokeninzing/Lexing）</p>
<p>这个过程会将由字符组成的字符串分解成(对编程语言来说)有意义的代码块，这些代 码块被称为词法单元(token)。例如，考虑程序var a = 2;。这段程序通常会被分解成 为下面这些词法单元:var、a、=、2 、;。空格是否会被当作词法单元，取决于空格在 这门语言中是否具有意义。 </p>
<p><strong>白话解析：这个过程主要是为了将一句句js代码转换成词法单元流(数组)，虽然不是很准确可以简单理解为将String按特定规则转化为Array。</strong></p>
<p><strong>衍生知识：</strong></p>
<p>分词(tokenizing)和词法分析(Lexing)之间的区别是非常微妙、晦涩的， 主要差异在于词法单元的识别是通过有状态还是无状态的方式进行的。简 单来说，如果词法单元生成器在判断 a 是一个独立的词法单元还是其他词法 单元的一部分时，调用的是有状态的解析规则，那么这个过程就被称为词法 分析。</p>
<p>[2] 解析／语法分析 (Parsing)</p>
<p>这个过程是将词法单元流(数组)转换成一个由元素逐级嵌套所组成的代表了程序语法 结构的树。这个树被称为“抽象语法树”(Abstract Syntax Tree，AST)。<br>var a = 2; 的抽象语法树中可能会有一个叫作 VariableDeclaration 的顶级节点，接下 来是一个叫作 Identifier(它的值是 a)的子节点，以及一个叫作 AssignmentExpression 的子节点。AssignmentExpression 节点有一个叫作 NumericLiteral(它的值是 2)的子 节点。</p>
<p><strong>白话解析：这个过程主要是将词法单元流转换为AST，虽然不是很准确可以简单理解将string 按特定规则转换为tree，以便代码生成时转换为机器码</strong></p>
<p>[3] 代码生成</p>
<p>将 AST 转换为可执行代码的过程称被称为代码生成。这个过程与语言、目标平台等息 息相关。<br>抛开具体细节，简单来说就是有某种方法可以将 var a = 2; 的 AST 转化为一组机器指令，用来创建一个叫作 a 的变量(包括分配内存等)，并将一个值储存在 a 中</p>
<p><strong>白话解析：这个过程主要是将AST根据平台差异转换为机器码，让计算机进行执行代码</strong></p>
<h5 id="3-javascript的编译与传统编译型语言的区别-解释型语言-："><a href="#3-javascript的编译与传统编译型语言的区别-解释型语言-：" class="headerlink" title="(3) javascript的编译与传统编译型语言的区别(解释型语言)："></a>(3) javascript的编译与传统编译型语言的区别(解释型语言)：</h5><p>比起只有3步的编译型语言，编译过程复杂的多，和书上一样只做宏观理解来了解决一下差别</p>
<p>简单总结下来说，由于js是解释型语言，会存在多次在执行前编译代码的情况造成：</p>
<ul>
<li>js没有引擎没有大量时间优化，因为编译过程并不在构建前</li>
<li>大部分情况下js编译代码是在执行前的几微秒，因此js引擎用了JIT等优化来保证性能</li>
</ul>
<p><strong>衍生知识：Just-In-Time Compiler(JIT) （挖个坑之后填）</strong></p>
<p>关于JIT可以参考该文：<a href="https://juejin.im/post/58c12adc128fe1006020dff9" target="_blank" rel="noopener">https://juejin.im/post/58c12adc128fe1006020dff9</a></p>
<p>Just-In-Time Compiler(JIT)实时编译：动态编译的一种形式，是一种提高程序运行效率的方法。通常，程序有两种运行方式：静态编译与动态解释。静态编译的程序在执行前全部被翻译为机器码，而解释执行的则是一句一句边运行边翻译。</p>
<p>即时编译器则混合了这二者，一句一句编译源代码，但是会将翻译过的代码缓存起来以降低性能损耗。相对于静态编译代码，即时编译的代码可以处理延迟绑定并增强安全性。</p>
<p>简单来说就是为了解决解释器的低效问题，后来的浏览器把编译器也引入进来，形成混合模式。</p>
<p>实现思路基本是：在 JavaScript 引擎中增加一个监视器（也叫分析器）。监视器监控着代码的运行情况，记录代码一共运行了多少次、如何运行的等信息。</p>
<h4 id="2-作用域解析过程"><a href="#2-作用域解析过程" class="headerlink" title="2.作用域解析过程"></a>2.作用域解析过程</h4><p>分析具体作用域之前需要一些前置知识，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>上面这句代码js引擎会认为有两个完全不同的声明：</p>
<ul>
<li>一个由js编译器处理：</li>
</ul>
<p>译器会在当前作用域中声明一个变量(如 果之前没有声明过)</p>
<ul>
<li>一个由js引擎在运行时处理：</li>
</ul>
<p>在运行时引擎会在作用域中查找该变量，如果能够找到就会对 它赋值。</p>
<p>js运行这段代码的大背后致过程</p>
<p><strong>大致过程：</strong></p>
<ul>
<li>编译器首先会将这段程序分解成词法单元，然后将词法单元解析成一个树结构</li>
<li>编译器会在当前作用域中声明一个变量</li>
<li>运行时引擎会在作用域中查找该变量，如果能够找到就会对 它赋值。</li>
</ul>
<p>结果：如果引擎最终找到了 a 变量，就会将 2 赋值给它。否则引擎就会举手示意并抛出一个异 常!</p>
<h5 id="1-不完全正确："><a href="#1-不完全正确：" class="headerlink" title="[1] 不完全正确："></a>[1] 不完全正确：</h5><h5 id="2-正确理解："><a href="#2-正确理解：" class="headerlink" title="[2] 正确理解："></a>[2] 正确理解：</h5><p>变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量(如果之前没有声明过)，然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对 它赋值。</p>
<h4 id="4-编译器如何进行变量查找"><a href="#4-编译器如何进行变量查找" class="headerlink" title="4.编译器如何进行变量查找"></a>4.编译器如何进行变量查找</h4><p>编译器在编译过程的第二步中生成了代码，引擎执行它时，会通过查找变量 a 来判断它是 否已声明过。查找的过程由作用域进行协助，但是引擎执行怎样的查找，会影响最终的查 找结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>会进行两个查找，一个是LHS、一个RHS，</p>
<p>[1] LHS: 左侧查询</p>
<p>是一个赋值操作的左侧，当变量出现在赋值操作的左侧时进行 LHS 查询，而 LHS 查询则是试图 找到变量的容器本身。</p>
<p>[2] RHS： 右侧查询</p>
<p>是一个赋值操作的右侧，出现在右侧时进行 RHS 查询。RHS 查询与简单地查找某个变量的值别无二致。</p>
<p>例1:</p>
<p><code>`</code>javascript<br>console.log( a );<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其中对 a 的引用是一个 RHS 引用，因为这里 a 并没有赋予任何值。相应地，需要查找并取得 a 的值，这样才能将值传递给 console.log(..)。从这个角度说，RHS 并不是真正意义上的“赋 值操作的右侧”，更准确地说是“非左侧”。</span><br><span class="line"></span><br><span class="line">例2:</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">a = 2;</span><br></pre></td></tr></table></figure></p>
<p>这里对 a 的引用则是 LHS 引用，因为实际上我们并不关心当前的值是什么，只是想要为 =<br>2 这个赋值操作找到一个目标。</p>
<p>例3:</p>
<p><code>`</code>javascript<br>function foo(a) {<br>    // 隐式 var a； 所以存在一次 LHS<br>    console.log( a ); // 2  // console对象一次LHS, 所以存在一次需要查找a，RHS<br>}<br>foo( 2 ); // 一次 RHS<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">有LHS 又有 RHS</span><br><span class="line"></span><br><span class="line">**补充知识：函数声明需要LHS吗**</span><br><span class="line"></span><br><span class="line">否，可能会倾向于将函数声明 function foo(a) &#123;... 概念化为普通的变量声明 和赋值，比如 var foo、foo = function(a) &#123;...。如果这样理解的话，这 个函数声明将需要进行 LHS 查询。 然而还有一个重要的细微差别，编译器可以在代码生成的同时处理声明和值 的定义，比如在引擎执行代码时，并不会有线程专门用来将一个函数值“分 配给”foo。因此，将函数声明理解成前面讨论的 LHS 查询和赋值的形式并 不合适。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">测验：</span><br><span class="line"></span><br><span class="line">```javascirpt</span><br><span class="line">function foo(a) &#123;</span><br><span class="line">// var a; 一次LHS</span><br><span class="line">var b = a; // 一次LHS 一次 RHSreturn a + b;  ／／ 2次RHS</span><br><span class="line">&#125;var c = foo( 2 ); ／／ 一次LHS 一次RHS</span><br></pre></td></tr></table></figure></p>
<p>总结:</p>
<ul>
<li>3次LHS</li>
<li>2次RHS</li>
</ul>
<h4 id="5-作用域嵌套"><a href="#5-作用域嵌套" class="headerlink" title="5.作用域嵌套"></a>5.作用域嵌套</h4><p>作用域是根据名称查找变量的一套规则。实际情况中，通常需要同时顾及几个作用域。</p>
<h4 id="1-嵌套作用域"><a href="#1-嵌套作用域" class="headerlink" title="[1] 嵌套作用域"></a>[1] 嵌套作用域</h4><p>当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。</p>
<h4 id="2-遍历嵌套作用域链的规则"><a href="#2-遍历嵌套作用域链的规则" class="headerlink" title="[2]遍历嵌套作用域链的规则"></a>[2]遍历嵌套作用域链的规则</h4><p>此时变量查找：若当前作用域无法查找到变量，则会到在外层嵌套的作用域中继续查找，直到找到该变量或抵达最外层。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123; </span><br><span class="line">	<span class="built_in">console</span>.log( a + b );&#125;<span class="keyword">var</span> b = <span class="number">2</span>; foo( <span class="number">2</span> ); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>对 b 进行的 RHS 引用无法在函数 foo 内部完成，但可以在上一级作用域(在这个例子中就 是全局作用域)中完成。</p>
<p><strong>遍历嵌套作用域链的规则:</strong> </p>
<p>引擎从当前的执行作用域开始查找变量，如果找不到， 就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都 会停止。</p>
<h4 id="6-异常"><a href="#6-异常" class="headerlink" title="6.异常"></a>6.异常</h4><p>区分 LHS 和 RHS 是一件重要的原因其中之一是因为异常</p>
<ul>
<li><p>LHS</p>
<ul>
<li><p>非严格模式</p>
<p>当引擎执行 LHS 查询时，如果在顶层(全局作用域)中也无法找到目标变量，<br>全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎</p>
</li>
<li><p>严格模式</p>
<pre><code>严格模式禁止自动或隐式地创建全局变量，因此，在 严格模式中 LHS 查询失败时，并不会创建并        返回一个全局变量，引擎会抛出同 RHS 查询 失败时类似的 ReferenceError 异常。
</code></pre></li>
</ul>
</li>
<li><p>RHS</p>
<ul>
<li><p>查找不到目标变量</p>
<p>  RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError 异常</p>
<ul>
<li><p>查询找到了一个变量，但是对这个变量的值进行不合理的操作</p>
<p>比如试图对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的 属性，那么引擎会抛出另外一种类型的异常，叫作 TypeError。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://www.neohuang.com/child/2018/09/12/not-know-js-review-base-scope/" data-id="cjmn38npz000uujm7o2qtpsrs" class="article-share-link"><i class="fa fa-share"></i>Compartir</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            <!--
    
        <a href="http://www.neohuang.com/child/2018/09/12/not-know-js-review-base-scope/#comments" class="article-comment-link">Comentarios</a>
    
-->
        </footer>
    </div>
    
</article>



    <article id="post-js-reivew-event-level" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2018/09/11/js-reivew-event-level/">js复习事件的优先级和事件对象</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2018/09/11/js-reivew-event-level/">
            <time datetime="2018-09-10T16:00:00.000Z" itemprop="datePublished">2018-09-11</time>
        </a>
    </div>


                        
                        
                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h3 id="一、dom0-dom2-dom3事件区分"><a href="#一、dom0-dom2-dom3事件区分" class="headerlink" title="一、dom0 dom2 dom3事件区分"></a>一、dom0 dom2 dom3事件区分</h3><p>上篇当中有提到html内联事件、属性事件和事件监听回调事件，那他们和dom0 dom2 dom3事件有什么关系呢，这里简述下：</p>
<p>DOM Level”是描述DOM对象，方法和行为的规范集合。更高级别的DOM规范建立在之前的级别上。变化发生在两个方面：</p>
<ul>
<li><p>dom0事件模型: html事件、属性事件</p>
</li>
<li><p>dom1事件模型: 1级DOM标准中并没有定义事件相关的内容，所以没有所谓的1级DOM事件模型。</p>
</li>
<li><p>dom2事件模型: 监听器回调事件</p>
</li>
<li><p>dom3事件模型: 与绑定事件无关</p>
</li>
</ul>
<h3 id="二、什么是事件优先级"><a href="#二、什么是事件优先级" class="headerlink" title="二、什么是事件优先级"></a>二、什么是事件优先级</h3><h4 id="解释：事件执行的顺序"><a href="#解释：事件执行的顺序" class="headerlink" title="解释：事件执行的顺序"></a>解释：事件执行的顺序</h4><h5 id="1-几个看实例之前需要知道的概念："><a href="#1-几个看实例之前需要知道的概念：" class="headerlink" title="(1) 几个看实例之前需要知道的概念："></a>(1) 几个看实例之前需要知道的概念：</h5><ul>
<li>html事件会被属性事件覆盖</li>
</ul>
<h5 id="2-dom-0-只存在事件冒泡"><a href="#2-dom-0-只存在事件冒泡" class="headerlink" title="(2) dom 0 只存在事件冒泡"></a>(2) dom 0 只存在事件冒泡</h5><h5 id="3-dom2-支持事件冒泡和事件捕获"><a href="#3-dom2-支持事件冒泡和事件捕获" class="headerlink" title="(3) dom2 支持事件冒泡和事件捕获"></a>(3) dom2 支持事件冒泡和事件捕获</h5><ul>
<li>事件目标阶段，按绑定顺序事件</li>
<li>冒泡阶段事件执行顺序，属性事件会比监听执行早（哪个时间先绑定哪个先执行）</li>
</ul>
<p>分析实例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">id</span>=<span class="string">"body"</span> <span class="attr">onclick</span>=<span class="string">"htmlEvent1()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span> <span class="attr">onclick</span>=<span class="string">"htmlEvent2()"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"test"</span> <span class="attr">onclick</span>=<span class="string">"htmlEvent3"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> body = <span class="built_in">document</span>.getElementById(<span class="string">'body'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> test = <span class="built_in">document</span>.getElementById(<span class="string">'test'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    body.onclick = propsEvent1;</span></span><br><span class="line"><span class="undefined">    container.onclick = propsEvent2;</span></span><br><span class="line"><span class="undefined">    test.onclick = propsEvent3;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    body.addEventListener(<span class="string">'click'</span>,listenerEventC1,<span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">    container.addEventListener(<span class="string">'click'</span>,listenerEventC2,<span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">    test.addEventListener(<span class="string">'click'</span>,listenerEventC3,<span class="literal">true</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    body.addEventListener(<span class="string">'click'</span>,listenerEventB1,<span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript">    container.addEventListener(<span class="string">'click'</span>,listenerEventB2,<span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript">    test.addEventListener(<span class="string">'click'</span>,listenerEventB3,<span class="literal">false</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">htmlEvent1</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'htmlEvent1'</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">htmlEvent2</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'htmlEvent2'</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">htmlEvent3</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'htmlEvent3'</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">propsEvent1</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'propsEvent1'</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">propsEvent2</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'propsEvent2'</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">propsEvent3</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'propsEvent3'</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">listenerEventB1</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'listenerEventB1'</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">listenerEventB2</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'listenerEventB2'</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">listenerEventB3</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'listenerEventB3  '</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">listenerEventC1</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'listenerEventC1'</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">listenerEventC2</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'listenerEventC2'</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">listenerEventC3</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'listenerEventC3'</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript"><span class="comment">// 捕获阶段执行开始   </span></span></span><br><span class="line"><span class="javascript"><span class="comment">// listenerEventC1</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// listenerEventC2</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// 捕获事件执行完毕</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// 事件目标，按绑定顺序执行开始</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// propsEvent3</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// listenerEventC3</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// listenerEventB3  </span></span></span><br><span class="line"><span class="javascript"><span class="comment">// 事件目标，按书写顺序执行结束</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// 冒泡阶段开始，容器，根据书写顺序 （实际会是属性事件先执行，再监听起器）</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// propsEvent2</span></span></span><br><span class="line"><span class="javascript"><span class="comment">//	listenerEventB2</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// 冒泡阶段结束，容器，根据书写顺序</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// 冒泡阶段开始，body，根据书写顺序 （实际会是属性事件先执行，再监听起器）</span></span></span><br><span class="line"><span class="javascript"><span class="comment">//	propsEvent1</span></span></span><br><span class="line"><span class="javascript"><span class="comment">//	listenerEventB1</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// 冒泡阶段结束，body，根据书写顺序</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>原则一： 牢记事件绑定是浏览器绑定</li>
<li>原则二：事件向传播目标对象（捕获阶段），先出发事件监听</li>
<li>事件在目标阶段，按事件解析或事件被定义的事件执行 （简单理解可理解为js书写顺序）</li>
<li>事件上按事件解析或事件被定义的事件执行，如果包含html事件上执行，即使属性被覆盖了还是会先执行html事件（即被覆盖的属性事件）</li>
</ul>
<h4 id="4-事件传递和cs会影响事件传播有关（比如把外层div层级改动）"><a href="#4-事件传递和cs会影响事件传播有关（比如把外层div层级改动）" class="headerlink" title="(4)事件传递和cs会影响事件传播有关（比如把外层div层级改动）"></a>(4)事件传递和cs会影响事件传播有关（比如把外层div层级改动）</h4><p>不会，事件绑定与css显示不相关</p>
<p><strong>特例：</strong><br>假设绝对定位，住了遮挡元素 不会触发，（以弹窗插件为例）: 事件绑定只html结构有关</p>
<p><strong>特例中的特例：</strong></p>
<p>但是有一个例子可能会有事件穿透</p>
<p>移动端中的事件穿透：</p>
<p>touchstart touchend touchmove </p>
<ul>
<li><p>touch没有 300ms延迟</p>
</li>
<li><p>onclick 300ms延迟</p>
</li>
</ul>
<p>处理方式：</p>
<p>(1) 延迟消失弹窗</p>
<p>(2) 叠加层 300毫秒消失</p>
<h3 id="二、事件对象相关："><a href="#二、事件对象相关：" class="headerlink" title="二、事件对象相关："></a>二、事件对象相关：</h3><p>####（1）定义与兼容写法 </p>
<p>event：包含事件相关的所有信息</p>
<p>ie浏览器：绑定在window上</p>
<p>兼容性写法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> e = e || <span class="built_in">window</span>.event</span><br></pre></td></tr></table></figure>
<p>为了更好的兼容IE浏览器和非ie浏览器。<br>在ie浏览器中,window.event是全局变量,在非ie中，就需要自己传入一个参数来获取event啦，所以就有了var e = e||window.event</p>
<p>####（2）事件对象常用属性</p>
<p>参考： <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Event</a></p>
<ul>
<li><p>bubbles（只读）: 当前事件是否是冒泡事件 true：是，false：不是</p>
</li>
<li><p>cancelable: 代表当前事件是否可以取消默认行为：true： 可取消 （true可以passive优化） false：不可取消</p>
</li>
<li><p>currentTarget（只读）： 当前事件正在处理哪个元素</p>
</li>
<li><p>defaultPrevented（只读） ： 一个布尔值，表示了是否已经执行过了event.preventDefault()</p>
</li>
<li><p>detail： 事件相关的详细信息（数字表示，和事件api对比）</p>
</li>
<li><p>eventPhase(只读): 1捕获 2目标 3冒泡</p>
</li>
<li><p>target（只读）: 当前的目标元素是什么</p>
</li>
<li><p>Event.isTrusted（只读）：  指明事件是否是由浏览器（当用户点击实例后）或者由脚本（使用事件的创建方法，例如event.initEvent）启动。 （大部分都是浏览器事件，当然可以开发人员可以自定义生成）</p>
</li>
<li><p>Event.type(只读) : 类事件的类型（不区分大小写）。</p>
</li>
<li><p>Event.view ：关联视图，一般是当前window</p>
</li>
</ul>
<h4 id="（3）事件对象常用方法"><a href="#（3）事件对象常用方法" class="headerlink" title="（3）事件对象常用方法"></a>（3）事件对象常用方法</h4><ul>
<li>event.preventDefault</li>
</ul>
<p>取消事件（如果该事件可取消）: canable 为 true ，同时可以用passive优化，取消事件（如果该事件可取消）。</p>
<p>return fasle</p>
<ul>
<li>event.stopPropagation</li>
</ul>
<p>阻止事件进一步传播 （bubbles为true 可以调用, false不可），只阻止会往下层传播</p>
<ul>
<li>event.stopImmediatePropagation</li>
</ul>
<p>阻止事件进一步传播 （bubbles为true 可以调用, false不可），阻止传播之后函数不执行</p>
<p>阻止事件传播不会阻止事件默认行为，阻止事件默认行为，不会阻止事件传播</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://www.neohuang.com/child/2018/09/11/js-reivew-event-level/" data-id="cjmn38npk000cujm7dtwfluew" class="article-share-link"><i class="fa fa-share"></i>Compartir</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            <!--
    
        <a href="http://www.neohuang.com/child/2018/09/11/js-reivew-event-level/#comments" class="article-comment-link">Comentarios</a>
    
-->
        </footer>
    </div>
    
</article>



    <article id="post-js-reivew-event-mouse" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2018/09/11/js-reivew-event-mouse/">js复习鼠标事件笔记</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2018/09/11/js-reivew-event-mouse/">
            <time datetime="2018-09-10T16:00:00.000Z" itemprop="datePublished">2018-09-11</time>
        </a>
    </div>


                        
                        
                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h3 id="一、鼠标事件"><a href="#一、鼠标事件" class="headerlink" title="一、鼠标事件"></a>一、鼠标事件</h3><p>dom3事件模型中与鼠标事件相关的事件共12种鼠标事件</p>
<ul>
<li>5个点击相关</li>
<li>5个移动相关</li>
<li>1个滚动</li>
<li>1个选择事件</li>
</ul>
<p>点击相关事件：</p>
<ul>
<li><p>click</p>
</li>
<li><p>dblclick</p>
</li>
<li><p>contextmeun (次键点击)</p>
</li>
<li><p>mousedown</p>
</li>
<li><p>mouseup</p>
</li>
</ul>
<p>移动相关</p>
<ul>
<li><p>mousemove</p>
</li>
<li><p>mouseenter</p>
</li>
<li><p>mouseover</p>
</li>
<li><p>mouseleave</p>
</li>
<li><p>mouseout</p>
</li>
</ul>
<p>滚动</p>
<ul>
<li>wheel</li>
</ul>
<p>选择</p>
<ul>
<li>select</li>
</ul>
<p>click 执行顺序</p>
<p>dblclick 执行顺序</p>
<h3 id="二、relatedTarget"><a href="#二、relatedTarget" class="headerlink" title="二、relatedTarget"></a>二、relatedTarget</h3><p>参考：<a href="https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/relatedTarget" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/relatedTarget</a></p>
<p>定义：和事件相关的次要节点，如果存在返回节点，不存在返回null</p>
<p>target与relatedTarget总是相反的</p>
<p>与relatedTarget相关的事件，有以下8种：</p>
<ul>
<li>focusin</li>
<li>focusout</li>
<li>mouseover</li>
<li>mouseout</li>
<li>mouseenter</li>
<li>mouseleave</li>
<li>dragenter</li>
<li>dragexit</li>
</ul>
<p>###(1) mouseover与mouseenter（mouseout和mouseleave同理）的区别</p>
<h4 id="1-mouseover："><a href="#1-mouseover：" class="headerlink" title="[1]mouseover："></a>[1]mouseover：</h4><ul>
<li>特征：从事件节点进入其子节点也会触发事件，会向父节点冒泡</li>
<li>target: 移入进入节点</li>
<li>relatedTarget： 移入时离开的节点</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">content</span>=<span class="string">"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        #container &#123;</span></span><br><span class="line"><span class="undefined">            width: 200px;</span></span><br><span class="line"><span class="undefined">            height: 200px;</span></span><br><span class="line"><span class="undefined">            background-color: blue;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        #child &#123;</span></span><br><span class="line"><span class="undefined">            width: 100px;</span></span><br><span class="line"><span class="undefined">            height: 100px;</span></span><br><span class="line"><span class="undefined">            background-color: red;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span> <span class="attr">onmouseover</span>=<span class="string">"handleMouseover(event)"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"child"</span>&gt;</span>sddddd<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">handleMouseover</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(e);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-mouseenter："><a href="#2-mouseenter：" class="headerlink" title="[2]mouseenter："></a>[2]mouseenter：</h4><ul>
<li>特征：从事件节点进入其子节点也会不会触发事件，不会向父节点冒泡</li>
<li>target: 移入进入节点</li>
<li>relatedTarget： 移入时离开的节点</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">content</span>=<span class="string">"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        #container &#123;</span></span><br><span class="line"><span class="undefined">            width: 200px;</span></span><br><span class="line"><span class="undefined">            height: 200px;</span></span><br><span class="line"><span class="undefined">            background-color: blue;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        #child &#123;</span></span><br><span class="line"><span class="undefined">            width: 100px;</span></span><br><span class="line"><span class="undefined">            height: 100px;</span></span><br><span class="line"><span class="undefined">            background-color: red;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span> <span class="attr">onmouseenter</span>=<span class="string">"handleMouseEnter(event)"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"child"</span>&gt;</span>sddddd<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">handleMouseEnter</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(e); <span class="comment">// 进入事件节点的子阶段不会触发</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-通过mouseover模拟mouseenter："><a href="#3-通过mouseover模拟mouseenter：" class="headerlink" title="[3]通过mouseover模拟mouseenter："></a>[3]通过mouseover模拟mouseenter：</h4><p><strong>(1) 模拟实现核心思路：</strong></p>
<p>只处理从外层移入的事件</p>
<p><strong>(2) 拆分步骤：</strong></p>
<p>mouseOver伴随以下几种情况</p>
<ul>
<li><p>外层节点移入事件节点 （relatedTarget: 外层节点）</p>
</li>
<li><p>事件节点往子节点移入</p>
<ul>
<li>事件节点往子节点移入 （relatedTarget: 事件节点）</li>
<li>事件节点的子节点往其他子节点移入 （relatedTarget: 事件节点子节点）</li>
</ul>
</li>
</ul>
<p><strong>(3)因此模拟处理的关键：</strong></p>
<p><strong>判断次要节点不是 本身也不是其子节点</strong></p>
<p><strong>(4)是否可以只判断，非自身节点</strong></p>
<p>不能，若只判断判断次要节点不是本身，绝大多数情况可以解决但是一个前提是需要事件节点与子节点间有空间才可以判断，如果没有空间可能是更上一层的节点</p>
<p><strong>(5)是否可以通过阻止子节点冒泡来解决</strong></p>
<p>不能，只能解决子节点之间移动的问题，不能解决子节点往事件节点上的触发</p>
<p><strong>(6)是否可以通过事件流的方式解决</strong></p>
<p>不能，通过addEventListener解决： 无效（会产生新的mouseover，有一个完整的事件流）、</p>
<h4 id="2-鼠标事件对应的事件处理程序"><a href="#2-鼠标事件对应的事件处理程序" class="headerlink" title="(2)鼠标事件对应的事件处理程序"></a>(2)鼠标事件对应的事件处理程序</h4><p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent</a></p>
<h5 id="1-鼠标事件相关属性"><a href="#1-鼠标事件相关属性" class="headerlink" title="[1] 鼠标事件相关属性"></a>[1] 鼠标事件相关属性</h5><p>可以大致分为三类：</p>
<ul>
<li><p>位置相关</p>
<ul>
<li>screenX <strong>(相对屏幕位置)</strong>：他提供了鼠标相对于屏幕坐标系的水平偏移量</li>
<li>clientX (相对可是区域位置，浏览器窗口)</li>
<li>pageX (相对于html文档) （非标准属性）兼容：pageX = clientX + scrollLeft + clientLeft</li>
<li>offesetX： 鼠标在的位置与触发元素相距的距离，以content为参考点（ie属性非标准，但浏览器打多实现，基本通用）</li>
<li>movementX : 与mousemove搭配，两个连续的mousemove相隔的距离 （ie不支持，现代浏览器支持）</li>
</ul>
</li>
<li><p>键盘相关</p>
<ul>
<li>cotrrolKey:<br>点鼠标时，有没有按住cotrrol</li>
<li>shiftKey：<br>  点击点鼠标时，有没有按住shift        </li>
<li>altKey：<br>  点击点鼠标时，有没有按住alt</li>
<li>metaKey： （win键 command键）</li>
<li>button：-1（没有按键）鼠标移动  0 （主键） 1 （辅助键） 2 （次键） </li>
<li>buttons： 同时按下两个键，数字可能会变，3位2进制值  1 左 2 右 4 中<br>举例： 左中：5</li>
</ul>
</li>
</ul>
<h5 id="2-位置相关以及键盘相关注意事项"><a href="#2-位置相关以及键盘相关注意事项" class="headerlink" title="[2]位置相关以及键盘相关注意事项"></a>[2]位置相关以及键盘相关注意事项</h5><p>(1)强调 click只是主键点击</p>
<p>(2)其他键可以通过 mousedown mouseup</p>
<p>(3)preventDefalt可以注销contextmenu         </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">content</span>=<span class="string">"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        .context &#123;</span></span><br><span class="line"><span class="undefined">            background-color: pink;</span></span><br><span class="line"><span class="undefined">            width: 100px;</span></span><br><span class="line"><span class="undefined">            height: 100px;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"context"</span> <span class="attr">oncontextmenu</span>=<span class="string">"handleOnContextmenu(event)"</span>&gt;</span></span><br><span class="line">    21321</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">handleOnContextmenu</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    e.preventDefault(); <span class="comment">//阻止默认右键菜单</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'弹出自定义菜单'</span>);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>滚轮事件：</p>
<p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/wheel" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Events/wheel</a></p>
</li>
</ul>
<p> 当滚动鼠标滚轮或操作其它类似输入设备时会触发滚轮事件。滚轮事件替换了已被弃用的非标准mousewheel事件。</p>
<p>（1）mousewheel事件</p>
<ul>
<li>可以冒泡冒泡到document </li>
<li>wheeldelta: 是一个整值120的倍数 上滚120倍数 下滚是-120倍数 是滚动调的方向,一般只关心正数还是负数</li>
<li>mousewheel，documentmouse<br>存在detail wheelDelta 1的倍数 新版正3 -3，和标准相反</li>
<li>标准版本weel事件（html5）：大部分浏览器都支持<br>deltaX: 变量增量 X  浏览器数值不同<br>deltaY：变量增量 Y 浏览器数值不同<br>deltaZ: 变量增量 Z 浏览器数值不同</li>
</ul>
<h5 id="4-滚动鼠标事件注意点："><a href="#4-滚动鼠标事件注意点：" class="headerlink" title="[4]滚动鼠标事件注意点："></a>[4]滚动鼠标事件注意点：</h5><ul>
<li>要根据实际客户需求调研，客户版本（mdn文档）</li>
<li>wheeldelta 不一定是整数倍，线性滚轮鼠标不一定正数，mac触控板也模拟鼠标滚轮，就有可能是3的倍数（可能会触发几十次，并且可能有动画过度，wheelDealte可能还会继续改变）</li>
<li>不要相信wheeldelta的值</li>
<li>极限情况：wheeldelta（通常是抛物线曲线）会出现震动情况（一般是动画过程中旋转设备，切换屏幕）</li>
<li>鼠标滚动事件和页面滚动事件无关 （触摸设备手指滑，pc拖拽滚动条也不会触发滚动事件，mac放大不会触发，mac和安卓 2手指手势会触发）<br>只能通过滚轮或触控板触发</li>
<li>滚动到页面顶部和底部后也会继续触发</li>
</ul>
<h4 id="（3）防抖函数与节流函数"><a href="#（3）防抖函数与节流函数" class="headerlink" title="（3）防抖函数与节流函数"></a>（3）防抖函数与节流函数</h4><p>只叙述概念，之后文章具体分析源码与原理</p>
<p>根本原理是通过时间戳控制</p>
<h5 id="1-防抖函数"><a href="#1-防抖函数" class="headerlink" title="[1] 防抖函数"></a>[1] 防抖函数</h5><p>同一个时间处理，当超过设定时间后才触发，</p>
<p><strong>核心实现思路</strong>：2个事件发生间隔小于某个时间点，推迟执行</p>
<h5 id="2-节流函数"><a href="#2-节流函数" class="headerlink" title="[2] 节流函数"></a>[2] 节流函数</h5><p>同一个事件处理，设定时间内只触发一次 </p>
<p><strong>核心实现思路</strong>：2个事件发生间隔大于某个时间点，就执行</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://www.neohuang.com/child/2018/09/11/js-reivew-event-mouse/" data-id="cjmn38npl000eujm7tp0fgcjv" class="article-share-link"><i class="fa fa-share"></i>Compartir</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            <!--
    
        <a href="http://www.neohuang.com/child/2018/09/11/js-reivew-event-mouse/#comments" class="article-comment-link">Comentarios</a>
    
-->
        </footer>
    </div>
    
</article>



    <nav id="page-nav">
        <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Siguiente  &raquo;</a>
    </nav>
</section>
            
                <aside id="sidebar">
   
        
    <div class="widget-wrap">
        <h3 class="widget-title">Recientes</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/09/29/not-know-js-review-object/" class="thumbnail">
    
    
        <span style="background-image:url(/img/not-know-js-review.jpeg)" alt="你不知道的js复习笔记 (对象)" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2018/09/29/not-know-js-review-object/" class="title">你不知道的js复习笔记 (对象)</a></p>
                            <p class="item-date"><time datetime="2018-09-28T16:00:00.000Z" itemprop="datePublished">2018-09-29</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/09/25/not-know-js-review-this/" class="thumbnail">
    
    
        <span style="background-image:url(/img/not-know-js-review.jpeg)" alt="你不知道的js复习笔记 (this)" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2018/09/25/not-know-js-review-this/" class="title">你不知道的js复习笔记 (this)</a></p>
                            <p class="item-date"><time datetime="2018-09-24T16:00:00.000Z" itemprop="datePublished">2018-09-25</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/09/19/not-know-js-review-closure/" class="thumbnail">
    
    
        <span style="background-image:url(/img/not-know-js-review.jpeg)" alt="你不知道的js复习笔记 (作用域闭包)" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2018/09/19/not-know-js-review-closure/" class="title">你不知道的js复习笔记 (作用域闭包)</a></p>
                            <p class="item-date"><time datetime="2018-09-18T16:00:00.000Z" itemprop="datePublished">2018-09-19</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/09/13/not-know-js-review-lexical-scope /" class="thumbnail">
    
    
        <span style="background-image:url(/img/not-know-js-review.jpeg)" alt="你不知道的js复习笔记 (词法作用域)" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2018/09/13/not-know-js-review-lexical-scope /" class="title">你不知道的js复习笔记 (词法作用域)</a></p>
                            <p class="item-date"><time datetime="2018-09-12T16:00:00.000Z" itemprop="datePublished">2018-09-13</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/09/13/not-know-js-review-fp-scope-block-scope/" class="thumbnail">
    
    
        <span style="background-image:url(/img/not-know-js-review.jpeg)" alt="你不知道的js复习笔记 (词法作用域)" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2018/09/13/not-know-js-review-fp-scope-block-scope/" class="title">你不知道的js复习笔记 (词法作用域)</a></p>
                            <p class="item-date"><time datetime="2018-09-12T16:00:00.000Z" itemprop="datePublished">2018-09-13</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

    
        
    
        
    <div class="widget-wrap">
        <h3 class="widget-title">Archivos</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a><span class="archive-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    
        
    
        
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">Links</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="http://blog.zhaiyifan.cn/">MarkZhai</a>
                    </li>
                
                    <li>
                        <a href="http://silverd.cn/">SilverdJiang</a>
                    </li>
                
                    <li>
                        <a href="http://yownyang.github.io">YownYang</a>
                    </li>
                
                    <li>
                        <a href="http://zhukejin.com">PrimoZhu</a>
                    </li>
                
                    <li>
                        <a href="http://wjerryzhen11.github.io">JerryXu</a>
                    </li>
                
                    <li>
                        <a href="http://yocann.cn">CnnyChen</a>
                    </li>
                
            </ul>
        </div>
    </div>


    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
            
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2018 Neo<br>
            Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="http://github.com/ppoffice">PPOffice</a>
        </div>
    </div>
</footer>
        
    
    <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2131605"></script>




    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>